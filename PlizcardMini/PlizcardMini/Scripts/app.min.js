var $html = $('HTML');

$html.removeClass('no-js');

// Detecting touch
if ('ontouchstart' in window) {
	$html.addClass('touch');
} else {
	$html.addClass('no-touch');
}
/*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version: 3.1.12
 *
 * Requires: jQuery 1.2.2+
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));
// require "shards/masked_input/_masked_input.js"
// require "shards/icheck_checkboxes_radios/_icheck_checkboxes_radios.js"
// require "shards/selectize/_selectize.js"
// require "shards/dropdown/_dropdown.js"
/**
 * jQuery CSS Customizable Scrollbar
 *
 * Copyright 2014, Yuriy Khabarov
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * If you found bug, please contact me via email <13real008@gmail.com>
 *
 * @author Yuriy Khabarov aka Gromo
 * @version 0.2.5
 * @url https://github.com/gromo/jquery.scrollbar/
 *
 */
;
(function($, doc, win){
    'use strict';

    // init flags & variables
    var debug = false;
    var lmb = 1, px = "px";

    var browser = {
        "data": {},
        "macosx": win.navigator.platform.toLowerCase().indexOf('mac') !== -1,
        "mobile": /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(win.navigator.userAgent),
        "overlay": null,
        "scroll": null,
        "scrolls": [],
        "webkit": /WebKit/.test(win.navigator.userAgent),

        "log": debug ? function(data, toString){
            var output = data;
            if(toString && typeof data != "string"){
                output = [];
                $.each(data, function(i, v){
                    output.push('"' + i + '": ' + v);
                });
                output = output.join(", ");
            }
            if(win.console && win.console.log){
                win.console.log(output);
            } else {
                alert(output);
            }
        } : function(){

        }
    };

    var defaults = {
        "autoScrollSize": true,     // automatically calculate scrollsize
        "autoUpdate": true,         // update scrollbar if content/container size changed
        "debug": false,             // debug mode
        "disableBodyScroll": false, // disable body scroll if mouse over container
        "duration": 200,            // scroll animate duration in ms
        "ignoreMobile": false,       // ignore mobile devices
        "ignoreOverlay": false,      // ignore browsers with overlay scrollbars (mobile, MacOS)
        "scrollStep": 30,           // scroll step for scrollbar arrows
        "showArrows": false,        // add class to show arrows
        "stepScrolling": true,      // when scrolling to scrollbar mousedown position
        "type":"simple",            // [advanced|simple] scrollbar html type

        "scrollx": null,            // horizontal scroll element
        "scrolly": null,            // vertical scroll element

        "onDestroy": null,          // callback function on destroy,
        "onInit": null,             // callback function on first initialization
        "onScroll": null,           // callback function on content scrolling
        "onUpdate": null            // callback function on init/resize (before scrollbar size calculation)
    };


    var customScrollbar = function(container, options){

        if(!browser.scroll){
            browser.log("Init jQuery Scrollbar v0.2.5");
            browser.overlay = isScrollOverlaysContent();
            browser.scroll = getBrowserScrollSize();
            updateScrollbars();

            $(win).resize(function(){
                var forceUpdate = false;
                if(browser.scroll && (browser.scroll.height || browser.scroll.width)){
                    var scroll = getBrowserScrollSize();
                    if(scroll.height != browser.scroll.height || scroll.width != browser.scroll.width){
                        browser.scroll = scroll;
                        forceUpdate = true; // handle page zoom
                    }
                }
                updateScrollbars(forceUpdate);
            });
        }

        this.container = container;
        this.options = $.extend({}, defaults, win.jQueryScrollbarOptions || {});
        this.scrollTo = null;
        this.scrollx = {};
        this.scrolly = {};

        this.init(options);
    };

    customScrollbar.prototype = {

        destroy: function(){

            if(!this.wrapper){
                return;
            }

            // init variables
            var scrollLeft = this.container.scrollLeft();
            var scrollTop  = this.container.scrollTop();

            this.container.insertBefore(this.wrapper).css({
                "height":"",
                "margin":""
            })
            .removeClass("scroll-content")
            .removeClass("scroll-scrollx_visible")
            .removeClass("scroll-scrolly_visible")
            .off(".scrollbar")
            .scrollLeft(scrollLeft)
            .scrollTop(scrollTop);

            this.scrollx.scrollbar.removeClass("scroll-scrollx_visible").find("div").andSelf().off(".scrollbar");
            this.scrolly.scrollbar.removeClass("scroll-scrolly_visible").find("div").andSelf().off(".scrollbar");

            this.wrapper.remove();

            $(doc).add("body").off(".scrollbar");

            if($.isFunction(this.options.onDestroy))
                this.options.onDestroy.apply(this, [this.container]);
        },



        getScrollbar: function(d){

            var scrollbar = this.options["scroll" + d];
            var html = {
                "advanced":
                '<div class="scroll-element_corner"></div>' +
                '<div class="scroll-arrow scroll-arrow_less"></div>' +
                '<div class="scroll-arrow scroll-arrow_more"></div>' +
                '<div class="scroll-element_outer">' +
                '    <div class="scroll-element_size"></div>' + // required! used for scrollbar size calculation !
                '    <div class="scroll-element_inner-wrapper">' +
                '        <div class="scroll-element_inner scroll-element_track">'  + // used for handling scrollbar click
                '            <div class="scroll-element_inner-bottom"></div>' +
                '        </div>' +
                '    </div>' +
                '    <div class="scroll-bar">' +
                '        <div class="scroll-bar_body">' +
                '            <div class="scroll-bar_body-inner"></div>' +
                '        </div>' +
                '        <div class="scroll-bar_bottom"></div>' +
                '        <div class="scroll-bar_center"></div>' +
                '    </div>' +
                '</div>',

                "simple":
                '<div class="scroll-element_outer">' +
                '    <div class="scroll-element_size"></div>'  + // required! used for scrollbar size calculation !
                '    <div class="scroll-element_track"></div>' + // used for handling scrollbar click
                '    <div class="scroll-bar"></div>' +
                '</div>'
            };
            var type = html[this.options.type] ? this.options.type : "advanced";

            if(scrollbar){
                if(typeof(scrollbar) == "string"){
                    scrollbar = $(scrollbar).appendTo(this.wrapper);
                } else {
                    scrollbar = $(scrollbar);
                }
            } else {
                scrollbar = $("<div>").addClass("scroll-element").html(html[type]).appendTo(this.wrapper);
            }

            if(this.options.showArrows){
                scrollbar.addClass("scroll-element_arrows_visible");
            }

            return scrollbar.addClass("scroll-" + d);
        },



        init: function(options){

            // init variables
            var S = this;

            var c = this.container;
            var cw = this.containerWrapper || c;
            var o = $.extend(this.options, options || {});
            var s = {
                "x": this.scrollx,
                "y": this.scrolly
            };
            var w = this.wrapper;

            var initScroll = {
                "scrollLeft": c.scrollLeft(),
                "scrollTop": c.scrollTop()
            };

            // do not init if in ignorable browser
            if ((browser.mobile && o.ignoreMobile) || (browser.overlay && o.ignoreOverlay)) {
                return false;
            }

            // init scroll container
            if(!w){
                this.wrapper = w = $('<div>').addClass('scroll-wrapper').addClass(c.attr('class'))
                .css('position', c.css('position') == 'absolute' ? 'absolute' : 'relative')
                .insertBefore(c).append(c);

                if(c.is('textarea')){
                    this.containerWrapper = cw = $('<div>').insertBefore(c).append(c);
                    w.addClass('scroll-textarea');

	                // Added for "disabled" support
	                if (c.prop('disabled')) {
		                w.addClass('disabled');
	                }
                }

                cw.addClass("scroll-content").css({
                    "height":"",
                    "margin-bottom": browser.scroll.height * -1 + px,
                    "margin-right":  browser.scroll.width  * -1 + px
                });

                c.on("scroll.scrollbar", function(event){
                    if($.isFunction(o.onScroll)){
                        o.onScroll.call(S, {
                            "maxScroll": s.y.maxScrollOffset,
                            "scroll": c.scrollTop(),
                            "size": s.y.size,
                            "visible": s.y.visible
                        }, {
                            "maxScroll": s.x.maxScrollOffset,
                            "scroll": c.scrollLeft(),
                            "size": s.x.size,
                            "visible": s.x.visible
                        });
                    }
                    s.x.isVisible && s.x.scroller.css("left", c.scrollLeft() * s.x.kx + px);
                    s.y.isVisible && s.y.scroller.css("top",  c.scrollTop()  * s.y.kx + px);
                });

                /* prevent native scrollbars to be visible on #anchor click */
                w.on("scroll", function(){
                    w.scrollTop(0).scrollLeft(0);
                });

                if(o.disableBodyScroll){
                    var handleMouseScroll = function(event){
                        isVerticalScroll(event) ?
                        s.y.isVisible && s.y.mousewheel(event) :
                        s.x.isVisible && s.x.mousewheel(event);
                    };
                    w.on({
                        "MozMousePixelScroll.scrollbar": handleMouseScroll,
                        "mousewheel.scrollbar": handleMouseScroll
                    });

                    if(browser.mobile){
                        w.on("touchstart.scrollbar", function(event){
                            var touch = event.originalEvent.touches && event.originalEvent.touches[0] || event;
                            var originalTouch = {
                                "pageX": touch.pageX,
                                "pageY": touch.pageY
                            };
                            var originalScroll = {
                                "left": c.scrollLeft(),
                                "top": c.scrollTop()
                            };
                            $(doc).on({
                                "touchmove.scrollbar": function(event){
                                    var touch = event.originalEvent.targetTouches && event.originalEvent.targetTouches[0] || event;
                                    c.scrollLeft(originalScroll.left + originalTouch.pageX - touch.pageX);
                                    c.scrollTop(originalScroll.top + originalTouch.pageY - touch.pageY);
                                    event.preventDefault();
                                },
                                "touchend.scrollbar": function(){
                                    $(doc).off(".scrollbar");
                                }
                            });
                        });
                    }
                }
                if($.isFunction(o.onInit))
                    o.onInit.apply(this, [c]);
            } else {
                cw.css({
                    "height":"",
                    "margin-bottom": browser.scroll.height * -1 + px,
                    "margin-right":  browser.scroll.width  * -1 + px
                });
            }

            // init scrollbars & recalculate sizes
            $.each(s, function(d, scrollx){

                var scrollCallback = null;
                var scrollForward = 1;
                var scrollOffset = (d == "x") ? "scrollLeft" : "scrollTop";
                var scrollStep = o.scrollStep;
                var scrollTo = function(){
                    var currentOffset = c[scrollOffset]();
                    c[scrollOffset](currentOffset + scrollStep);
                    if(scrollForward == 1 && (currentOffset + scrollStep) >= scrollToValue)
                        currentOffset = c[scrollOffset]();
                    if(scrollForward == -1 && (currentOffset + scrollStep) <= scrollToValue)
                        currentOffset = c[scrollOffset]();
                    if(c[scrollOffset]() == currentOffset && scrollCallback){
                        scrollCallback();
                    }
                }
                var scrollToValue = 0;

                if(!scrollx.scrollbar){

                    scrollx.scrollbar = S.getScrollbar(d);
                    scrollx.scroller = scrollx.scrollbar.find(".scroll-bar");

                    scrollx.mousewheel = function(event){

                        if(!scrollx.isVisible || (d == 'x' && isVerticalScroll(event))){
                            return true;
                        }
                        if(d == 'y' && !isVerticalScroll(event)){
                            s.x.mousewheel(event);
                            return true;
                        }

                        var delta = event.originalEvent.wheelDelta * -1 || event.originalEvent.detail;
                        var maxScrollValue = scrollx.size - scrollx.visible - scrollx.offset;

                        if(!((scrollToValue <= 0 && delta < 0) || (scrollToValue >= maxScrollValue && delta > 0))){
                            scrollToValue = scrollToValue + delta;
                            if(scrollToValue < 0)
                                scrollToValue = 0;
                            if(scrollToValue > maxScrollValue)
                                scrollToValue = maxScrollValue;

                            S.scrollTo = S.scrollTo || {};
                            S.scrollTo[scrollOffset] = scrollToValue;
                            setTimeout(function(){
                                if(S.scrollTo){
                                    c.stop().animate(S.scrollTo, 240, 'linear', function(){
                                        scrollToValue = c[scrollOffset]();
                                    });
                                    S.scrollTo = null;
                                }
                            }, 1);
                        }

                        event.preventDefault();
                        return false;
                    };

                    scrollx.scrollbar.on({
                        "MozMousePixelScroll.scrollbar": scrollx.mousewheel,
                        "mousewheel.scrollbar": scrollx.mousewheel,
                        "mouseenter.scrollbar": function(){
                            scrollToValue = c[scrollOffset]();
                        }
                    });

                    // handle arrows & scroll inner mousedown event
                    scrollx.scrollbar.find(".scroll-arrow, .scroll-element_track")
                    .on("mousedown.scrollbar", function(event){

                        if(event.which != lmb)
                            return true;

                        scrollForward = 1;

                        var data = {
                            "eventOffset": event[(d == "x") ? "pageX" : "pageY"],
                            "maxScrollValue": scrollx.size - scrollx.visible - scrollx.offset,
                            "scrollbarOffset": scrollx.scroller.offset()[(d == "x") ? "left" : "top"],
                            "scrollbarSize": scrollx.scroller[(d == "x") ? "outerWidth" : "outerHeight"]()
                        };
                        var timeout = 0, timer = 0;

                        if($(this).hasClass('scroll-arrow')){
                            scrollForward = $(this).hasClass("scroll-arrow_more") ? 1 : -1;
                            scrollStep = o.scrollStep * scrollForward;
                            scrollToValue = scrollForward > 0 ? data.maxScrollValue : 0;
                        } else {
                            scrollForward = (data.eventOffset > (data.scrollbarOffset + data.scrollbarSize) ? 1
                                : (data.eventOffset < data.scrollbarOffset ? -1 : 0));
                            scrollStep = Math.round(scrollx.visible * 0.75) * scrollForward;
                            scrollToValue = (data.eventOffset - data.scrollbarOffset -
                                (o.stepScrolling ? (scrollForward == 1 ? data.scrollbarSize : 0)
                                    : Math.round(data.scrollbarSize / 2)));
                            scrollToValue = c[scrollOffset]() + (scrollToValue / scrollx.kx);
                        }

                        S.scrollTo = S.scrollTo || {};
                        S.scrollTo[scrollOffset] = o.stepScrolling ? c[scrollOffset]() + scrollStep : scrollToValue;

                        if(o.stepScrolling){
                            scrollCallback = function(){
                                scrollToValue = c[scrollOffset]();
                                clearInterval(timer);
                                clearTimeout(timeout);
                                timeout = 0;
                                timer = 0;
                            };
                            timeout = setTimeout(function(){
                                timer = setInterval(scrollTo, 40);
                            }, o.duration + 100);
                        }

                        setTimeout(function(){
                            if(S.scrollTo){
                                c.animate(S.scrollTo, o.duration);
                                S.scrollTo = null;
                            }
                        }, 1);

                        return handleMouseDown(scrollCallback, event);
                    });

                    // handle scrollbar drag'n'drop
                    scrollx.scroller.on("mousedown.scrollbar", function(event){

                        if(event.which != lmb)
                            return true;

                        var eventPosition = event[(d == "x")? "pageX" : "pageY"];
                        var initOffset = c[scrollOffset]();

                        scrollx.scrollbar.addClass("scroll-draggable");

                        $(doc).on("mousemove.scrollbar", function(event){
                            var diff = parseInt((event[(d == "x")? "pageX" : "pageY"] - eventPosition) / scrollx.kx, 10);
                            c[scrollOffset](initOffset + diff);
                        });

                        return handleMouseDown(function(){
                            scrollx.scrollbar.removeClass("scroll-draggable");
                            scrollToValue = c[scrollOffset]();
                        }, event);
                    });
                }
            });

            // remove classes & reset applied styles
            $.each(s, function(d, scrollx){
                var scrollClass = "scroll-scroll" + d + "_visible";
                var scrolly = (d == "x") ? s.y : s.x;

                scrollx.scrollbar.removeClass(scrollClass);
                scrolly.scrollbar.removeClass(scrollClass);
                cw.removeClass(scrollClass);
            });

            // calculate init sizes
            $.each(s, function(d, scrollx){
                $.extend(scrollx, (d == "x") ? {
                    "offset": parseInt(c.css("left"), 10) || 0,
                    "size": c.prop("scrollWidth"),
                    "visible": w.width()
                } : {
                    "offset": parseInt(c.css("top"), 10) || 0,
                    "size": c.prop("scrollHeight"),
                    "visible": w.height()
                });
            });


            var updateScroll = function(d, scrollx){

                var scrollClass = "scroll-scroll" + d + "_visible";
                var scrolly = (d == "x") ? s.y : s.x;
                var offset = parseInt(c.css((d == "x") ? "left" : "top"), 10) || 0;

                var AreaSize = scrollx.size;
                var AreaVisible = scrollx.visible + offset;

                scrollx.isVisible = (AreaSize - AreaVisible) > 1; // bug in IE9/11 with 1px diff
                if(scrollx.isVisible){
                    scrollx.scrollbar.addClass(scrollClass);
                    scrolly.scrollbar.addClass(scrollClass);
                    cw.addClass(scrollClass);
                } else {
                    scrollx.scrollbar.removeClass(scrollClass);
                    scrolly.scrollbar.removeClass(scrollClass);
                    cw.removeClass(scrollClass);
                }

                if(d == "y" && (scrollx.isVisible || scrollx.size < scrollx.visible)){
                    cw.css("height", (AreaVisible + browser.scroll.height) + px);
                }

                if(s.x.size != c.prop("scrollWidth")
                    || s.y.size != c.prop("scrollHeight")
                    || s.x.visible != w.width()
                    || s.y.visible != w.height()
                    || s.x.offset  != (parseInt(c.css("left"), 10) || 0)
                    || s.y.offset  != (parseInt(c.css("top"), 10) || 0)
                    ){
                    $.each(s, function(d, scrollx){
                        $.extend(scrollx, (d == "x") ? {
                            "offset": parseInt(c.css("left"), 10) || 0,
                            "size": c.prop("scrollWidth"),
                            "visible": w.width()
                        } : {
                            "offset": parseInt(c.css("top"), 10) || 0,
                            "size": c.prop("scrollHeight"),
                            "visible": w.height()
                        });
                    });
                    updateScroll(d == "x" ? "y" : "x", scrolly);
                }
            };
            $.each(s, updateScroll);

            if($.isFunction(o.onUpdate))
                o.onUpdate.apply(this, [c]);

            // calculate scroll size
            $.each(s, function(d, scrollx){

                var cssOffset = (d == "x") ? "left" : "top";
                var cssFullSize = (d == "x") ? "outerWidth" : "outerHeight";
                var cssSize = (d == "x") ? "width" : "height";
                var offset = parseInt(c.css(cssOffset), 10) || 0;

                var AreaSize = scrollx.size;
                var AreaVisible = scrollx.visible + offset;

                var scrollSize = scrollx.scrollbar.find(".scroll-element_size");
                scrollSize = scrollSize[cssFullSize]() + (parseInt(scrollSize.css(cssOffset), 10) || 0);

                if(o.autoScrollSize){
                    scrollx.scrollbarSize = parseInt(scrollSize * AreaVisible / AreaSize, 10);
                    scrollx.scroller.css(cssSize, scrollx.scrollbarSize + px);
                }

                scrollx.scrollbarSize = scrollx.scroller[cssFullSize]();
                scrollx.kx = ((scrollSize - scrollx.scrollbarSize) / (AreaSize - AreaVisible)) || 1;
                scrollx.maxScrollOffset = AreaSize - AreaVisible;
            });

            c.scrollLeft(initScroll.scrollLeft).scrollTop(initScroll.scrollTop).trigger("scroll");
        }
    };

    /*
     * Extend jQuery as plugin
     *
     * @param {object|string} options or command to execute
     * @param {object|array} args additional arguments as array []
     */
    $.fn.scrollbar = function(options, args){

        var toReturn = this;

        if(options === "get")
            toReturn = null;

        this.each(function() {

            var container = $(this);

            if(container.hasClass("scroll-wrapper")
                || container.get(0).nodeName == "body"){
                return true;
            }

            var instance = container.data("scrollbar");
            if(instance){
                if(options === "get"){
                    toReturn = instance;
                    return false;
                }

                var func = (typeof options == "string" && instance[options]) ? options : "init";
                instance[func].apply(instance, $.isArray(args) ? args : []);

                if(options === "destroy"){
                    container.removeData("scrollbar");
                    while($.inArray(instance, browser.scrolls) >= 0)
                        browser.scrolls.splice($.inArray(instance, browser.scrolls), 1);
                }
            } else {
                if(typeof options != "string"){
                    instance = new customScrollbar(container, options);
                    container.data("scrollbar", instance);
                    browser.scrolls.push(instance);
                }
            }
            return true;
        });

        return toReturn;
    };

    /**
     * Connect default options to global object
     */
    $.fn.scrollbar.options = defaults;

    /**
     * Extend AngularJS as UI directive
     *
     *
     */
    if(win.angular){
        (function(angular){
            var app = angular.module('jQueryScrollbar', []);
            app.directive('jqueryScrollbar', function(){
                return {
                    "link": function(scope, element){
                        element.scrollbar(scope.options).on('$destroy', function(){
                            element.scrollbar('destroy');
                        });
                    },
                    "restring": "AC",
                    "scope": {
                        "options": "=jqueryScrollbar"
                    }
                };
            });
        })(win.angular);
    }

    /**
     * Check if scroll content/container size is changed
     */
    var timer = 0, timerCounter = 0;
    var updateScrollbars = function(force){
        var i, c, o, s, w, x, y;
        for( i = 0; i < browser.scrolls.length; i++){
            s = browser.scrolls[i];
            c = s.container;
            o = s.options;
            w = s.wrapper;
            x = s.scrollx;
            y = s.scrolly;
            if(force || (o.autoUpdate && w && w.is(":visible") &&
                (c.prop("scrollWidth") != x.size
                    || c.prop("scrollHeight") != y.size
                    || w.width()  != x.visible
                    || w.height() != y.visible
                    ))){
                s.init();

                if(debug){
                    browser.log({
                        "scrollHeight":  c.prop("scrollHeight") + ":" + s.scrolly.size,
                        "scrollWidth":   c.prop("scrollWidth") + ":" + s.scrollx.size,
                        "visibleHeight": w.height() + ":" + s.scrolly.visible,
                        "visibleWidth":  w.width() + ":" + s.scrollx.visible
                    }, true);
                    timerCounter++;
                }
            }
        }
        if(debug && timerCounter > 10){
            browser.log("Scroll updates exceed 10");
            updateScrollbars = function(){};
        } else {
            clearTimeout(timer);
            timer = setTimeout(updateScrollbars, 300);
        }
    };

    /* ADDITIONAL FUNCTIONS */
    /**
     * Get native browser scrollbar size (height/width)
     *
     * @param {Boolean} actual size or CSS size, default - CSS size
     * @returns {Object} with height, width
     */
    function getBrowserScrollSize(actualSize){

        if(browser.webkit && !actualSize){
            return {
                "height": 0,
                "width": 0
            };
        }

        if(!browser.data.outer){
            var css = {
                "border":  "none",
                "box-sizing": "content-box",
                "height":  "200px",
                "margin":  "0",
                "padding": "0",
                "width":   "200px"
            };
            browser.data.inner = $("<div>").css($.extend({}, css));
            browser.data.outer = $("<div>").css($.extend({
                "left":       "-1000px",
                "overflow":   "scroll",
                "position":   "absolute",
                "top":        "-1000px"
            }, css)).append(browser.data.inner).appendTo("body");
        }

        browser.data.outer.scrollLeft(1000).scrollTop(1000);

        return {
            "height": Math.ceil((browser.data.outer.offset().top - browser.data.inner.offset().top) || 0),
            "width": Math.ceil((browser.data.outer.offset().left - browser.data.inner.offset().left) || 0)
        };
    }

    function handleMouseDown(callback, event){
        $(doc).on({
            "blur.scrollbar": function(){
                $(doc).add('body').off('.scrollbar');
                callback && callback();
            },
            "dragstart.scrollbar": function(event){
                event.preventDefault();
                return false;
            },
            "mouseup.scrollbar": function(){
                $(doc).add('body').off('.scrollbar');
                callback && callback();
            }
        });
        $("body").on({
            "selectstart.scrollbar": function(event){
                event.preventDefault();
                return false;
            }
        });
        event && event.preventDefault();
        return false;
    }

    /**
     * Check if native browser scrollbars overlay content
     *
     * @returns {Boolean}
     */
    function isScrollOverlaysContent(){
        var scrollSize = getBrowserScrollSize(true);
        return !(scrollSize.height || scrollSize.width);
    }

    function isVerticalScroll(event){
        var e = event.originalEvent;
        if (e.axis && e.axis === e.HORIZONTAL_AXIS)
            return false;
        if (e.wheelDeltaX)
            return false;
        return true;
    }

})(jQuery, document, window);
// require "shards/nephrite/_nephrite.js"
/**
 * Swiper 3.2.5
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 *
 * http://www.idangero.us/swiper/
 *
 * Copyright 2015, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 *
 * Licensed under MIT
 *
 * Released on: November 21, 2015
 */
(function () {
	'use strict';
	var $;
	/*===========================
	 Swiper
	 ===========================*/
	var Swiper = function (container, params) {
		if (!(this instanceof Swiper)) return new Swiper(container, params);
		
		var defaults = {
			direction: 'horizontal',
			touchEventsTarget: 'container',
			initialSlide: 0,
			speed: 300,
			// autoplay
			autoplay: false,
			autoplayDisableOnInteraction: true,
			// To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
			iOSEdgeSwipeDetection: false,
			iOSEdgeSwipeThreshold: 20,
			// Free mode
			freeMode: false,
			freeModeMomentum: true,
			freeModeMomentumRatio: 1,
			freeModeMomentumBounce: true,
			freeModeMomentumBounceRatio: 1,
			freeModeSticky: false,
			freeModeMinimumVelocity: 0.02,
			// Autoheight
			autoHeight: false,
			// Set wrapper width
			setWrapperSize: false,
			// Virtual Translate
			virtualTranslate: false,
			// Effects
			effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow'
			coverflow: {
				rotate: 50,
				stretch: 0,
				depth: 100,
				modifier: 1,
				slideShadows : true
			},
			cube: {
				slideShadows: true,
				shadow: true,
				shadowOffset: 20,
				shadowScale: 0.94
			},
			fade: {
				crossFade: false
			},
			// Parallax
			parallax: false,
			// Scrollbar
			scrollbar: null,
			scrollbarHide: true,
			scrollbarDraggable: false,
			scrollbarSnapOnRelease: false,
			// Keyboard Mousewheel
			keyboardControl: false,
			mousewheelControl: false,
			mousewheelReleaseOnEdges: false,
			mousewheelInvert: false,
			mousewheelForceToAxis: false,
			mousewheelSensitivity: 1,
			// Hash Navigation
			hashnav: false,
			// Breakpoints
			breakpoints: undefined,
			// Slides grid
			spaceBetween: 0,
			slidesPerView: 1,
			slidesPerColumn: 1,
			slidesPerColumnFill: 'column',
			slidesPerGroup: 1,
			centeredSlides: false,
			slidesOffsetBefore: 0, // in px
			slidesOffsetAfter: 0, // in px
			// Round length
			roundLengths: false,
			// Touches
			touchRatio: 1,
			touchAngle: 45,
			simulateTouch: true,
			shortSwipes: true,
			longSwipes: true,
			longSwipesRatio: 0.5,
			longSwipesMs: 300,
			followFinger: true,
			onlyExternal: false,
			threshold: 0,
			touchMoveStopPropagation: true,
			// Pagination
			pagination: null,
			paginationElement: 'span',
			paginationClickable: false,
			paginationHide: false,
			paginationBulletRender: null,
			// Resistance
			resistance: true,
			resistanceRatio: 0.85,
			// Next/prev buttons
			nextButton: null,
			prevButton: null,
			// Progress
			watchSlidesProgress: false,
			watchSlidesVisibility: false,
			// Cursor
			grabCursor: false,
			// Clicks
			preventClicks: true,
			preventClicksPropagation: true,
			slideToClickedSlide: false,
			// Lazy Loading
			lazyLoading: false,
			lazyLoadingInPrevNext: false,
			lazyLoadingOnTransitionStart: false,
			// Images
			preloadImages: true,
			updateOnImagesReady: true,
			// loop
			loop: false,
			loopAdditionalSlides: 0,
			loopedSlides: null,
			// Control
			control: undefined,
			controlInverse: false,
			controlBy: 'slide', //or 'container'
			// Swiping/no swiping
			allowSwipeToPrev: true,
			allowSwipeToNext: true,
			swipeHandler: null, //'.swipe-handler',
			noSwiping: true,
			noSwipingClass: 'swiper-no-swiping',
			// NS
			slideClass: 'swiper-slide',
			slideActiveClass: 'swiper-slide-active',
			slideVisibleClass: 'swiper-slide-visible',
			slideDuplicateClass: 'swiper-slide-duplicate',
			slideNextClass: 'swiper-slide-next',
			slidePrevClass: 'swiper-slide-prev',
			wrapperClass: 'swiper-wrapper',
			bulletClass: 'swiper-pagination-bullet',
			bulletActiveClass: 'swiper-pagination-bullet-active',
			buttonDisabledClass: 'swiper-button-disabled',
			paginationHiddenClass: 'swiper-pagination-hidden',
			// Observer
			observer: false,
			observeParents: false,
			// Accessibility
			a11y: false,
			prevSlideMessage: 'Previous slide',
			nextSlideMessage: 'Next slide',
			firstSlideMessage: 'This is the first slide',
			lastSlideMessage: 'This is the last slide',
			paginationBulletMessage: 'Go to slide {{index}}',
			// Callbacks
			runCallbacksOnInit: true
			/*
			 Callbacks:
			 onInit: function (swiper)
			 onDestroy: function (swiper)
			 onClick: function (swiper, e)
			 onTap: function (swiper, e)
			 onDoubleTap: function (swiper, e)
			 onSliderMove: function (swiper, e)
			 onSlideChangeStart: function (swiper)
			 onSlideChangeEnd: function (swiper)
			 onTransitionStart: function (swiper)
			 onTransitionEnd: function (swiper)
			 onImagesReady: function (swiper)
			 onProgress: function (swiper, progress)
			 onTouchStart: function (swiper, e)
			 onTouchMove: function (swiper, e)
			 onTouchMoveOpposite: function (swiper, e)
			 onTouchEnd: function (swiper, e)
			 onReachBeginning: function (swiper)
			 onReachEnd: function (swiper)
			 onSetTransition: function (swiper, duration)
			 onSetTranslate: function (swiper, translate)
			 onAutoplayStart: function (swiper)
			 onAutoplayStop: function (swiper),
			 onLazyImageLoad: function (swiper, slide, image)
			 onLazyImageReady: function (swiper, slide, image)
			 */
			
		};
		var initialVirtualTranslate = params && params.virtualTranslate;
		
		params = params || {};
		var originalParams = {};
		for (var param in params) {
			if (typeof params[param] === 'object') {
				originalParams[param] = {};
				for (var deepParam in params[param]) {
					originalParams[param][deepParam] = params[param][deepParam];
				}
			}
			else {
				originalParams[param] = params[param];
			}
		}
		for (var def in defaults) {
			if (typeof params[def] === 'undefined') {
				params[def] = defaults[def];
			}
			else if (typeof params[def] === 'object') {
				for (var deepDef in defaults[def]) {
					if (typeof params[def][deepDef] === 'undefined') {
						params[def][deepDef] = defaults[def][deepDef];
					}
				}
			}
		}
		
		// Swiper
		var s = this;
		
		// Params
		s.params = params;
		s.originalParams = originalParams;
		
		// Classname
		s.classNames = [];
		/*=========================
		 Dom Library and plugins
		 ===========================*/
		if (typeof $ !== 'undefined' && typeof Dom7 !== 'undefined'){
			$ = Dom7;
		}
		if (typeof $ === 'undefined') {
			if (typeof Dom7 === 'undefined') {
				$ = window.Dom7 || window.Zepto || window.jQuery;
			}
			else {
				$ = Dom7;
			}
			if (!$) return;
		}
		// Export it to Swiper instance
		s.$ = $;
		
		/*=========================
		 Breakpoints
		 ===========================*/
		s.currentBreakpoint = undefined;
		s.getActiveBreakpoint = function () {
			//Get breakpoint for window width
			if (!s.params.breakpoints) return false;
			var breakpoint = false;
			var points = [], point;
			for ( point in s.params.breakpoints ) {
				if (s.params.breakpoints.hasOwnProperty(point)) {
					points.push(point);
				}
			}
			points.sort(function (a, b) {
				return parseInt(a, 10) > parseInt(b, 10);
			});
			for (var i = 0; i < points.length; i++) {
				point = points[i];
				if (point >= window.innerWidth && !breakpoint) {
					breakpoint = point;
				}
			}
			return breakpoint || 'max';
		};
		s.setBreakpoint = function () {
			//Set breakpoint for window width and update parameters
			var breakpoint = s.getActiveBreakpoint();
			if (breakpoint && s.currentBreakpoint !== breakpoint) {
				var breakPointsParams = breakpoint in s.params.breakpoints ? s.params.breakpoints[breakpoint] : s.originalParams;
				for ( var param in breakPointsParams ) {
					s.params[param] = breakPointsParams[param];
				}
				s.currentBreakpoint = breakpoint;
			}
		};
		// Set breakpoint on load
		if (s.params.breakpoints) {
			s.setBreakpoint();
		}
		
		/*=========================
		 Preparation - Define Container, Wrapper and Pagination
		 ===========================*/
		s.container = $(container);
		if (s.container.length === 0) return;
		if (s.container.length > 1) {
			s.container.each(function () {
				new Swiper(this, params);
			});
			return;
		}
		
		// Save instance in container HTML Element and in data
		s.container[0].swiper = s;
		s.container.data('swiper', s);
		
		s.classNames.push('swiper-container-' + s.params.direction);
		
		if (s.params.freeMode) {
			s.classNames.push('swiper-container-free-mode');
		}
		if (!s.support.flexbox) {
			s.classNames.push('swiper-container-no-flexbox');
			s.params.slidesPerColumn = 1;
		}
		if (s.params.autoHeight) {
			s.classNames.push('swiper-container-autoheight');
		}
		// Enable slides progress when required
		if (s.params.parallax || s.params.watchSlidesVisibility) {
			s.params.watchSlidesProgress = true;
		}
		// Coverflow / 3D
		if (['cube', 'coverflow'].indexOf(s.params.effect) >= 0) {
			if (s.support.transforms3d) {
				s.params.watchSlidesProgress = true;
				s.classNames.push('swiper-container-3d');
			}
			else {
				s.params.effect = 'slide';
			}
		}
		if (s.params.effect !== 'slide') {
			s.classNames.push('swiper-container-' + s.params.effect);
		}
		if (s.params.effect === 'cube') {
			s.params.resistanceRatio = 0;
			s.params.slidesPerView = 1;
			s.params.slidesPerColumn = 1;
			s.params.slidesPerGroup = 1;
			s.params.centeredSlides = false;
			s.params.spaceBetween = 0;
			s.params.virtualTranslate = true;
			s.params.setWrapperSize = false;
		}
		if (s.params.effect === 'fade') {
			s.params.slidesPerView = 1;
			s.params.slidesPerColumn = 1;
			s.params.slidesPerGroup = 1;
			s.params.watchSlidesProgress = true;
			s.params.spaceBetween = 0;
			if (typeof initialVirtualTranslate === 'undefined') {
				s.params.virtualTranslate = true;
			}
		}
		
		// Grab Cursor
		if (s.params.grabCursor && s.support.touch) {
			s.params.grabCursor = false;
		}
		
		// Wrapper
		s.wrapper = s.container.children('.' + s.params.wrapperClass);
		
		// Pagination
		if (s.params.pagination) {
			s.paginationContainer = $(s.params.pagination);
			if (s.params.paginationClickable) {
				s.paginationContainer.addClass('swiper-pagination-clickable');
			}
		}
		
		// Is Horizontal
		function isH() {
			return s.params.direction === 'horizontal';
		}
		
		// RTL
		s.rtl = isH() && (s.container[0].dir.toLowerCase() === 'rtl' || s.container.css('direction') === 'rtl');
		if (s.rtl) {
			s.classNames.push('swiper-container-rtl');
		}
		
		// Wrong RTL support
		if (s.rtl) {
			s.wrongRTL = s.wrapper.css('display') === '-webkit-box';
		}
		
		// Columns
		if (s.params.slidesPerColumn > 1) {
			s.classNames.push('swiper-container-multirow');
		}
		
		// Check for Android
		if (s.device.android) {
			s.classNames.push('swiper-container-android');
		}
		
		// Add classes
		s.container.addClass(s.classNames.join(' '));
		
		// Translate
		s.translate = 0;
		
		// Progress
		s.progress = 0;
		
		// Velocity
		s.velocity = 0;
		
		/*=========================
		 Locks, unlocks
		 ===========================*/
		s.lockSwipeToNext = function () {
			s.params.allowSwipeToNext = false;
		};
		s.lockSwipeToPrev = function () {
			s.params.allowSwipeToPrev = false;
		};
		s.lockSwipes = function () {
			s.params.allowSwipeToNext = s.params.allowSwipeToPrev = false;
		};
		s.unlockSwipeToNext = function () {
			s.params.allowSwipeToNext = true;
		};
		s.unlockSwipeToPrev = function () {
			s.params.allowSwipeToPrev = true;
		};
		s.unlockSwipes = function () {
			s.params.allowSwipeToNext = s.params.allowSwipeToPrev = true;
		};
		
		/*=========================
		 Round helper
		 ===========================*/
		function round(a) {
			return Math.floor(a);
		}
		/*=========================
		 Set grab cursor
		 ===========================*/
		if (s.params.grabCursor) {
			s.container[0].style.cursor = 'move';
			s.container[0].style.cursor = '-webkit-grab';
			s.container[0].style.cursor = '-moz-grab';
			s.container[0].style.cursor = 'grab';
		}
		/*=========================
		 Update on Images Ready
		 ===========================*/
		s.imagesToLoad = [];
		s.imagesLoaded = 0;
		
		s.loadImage = function (imgElement, src, srcset, checkForComplete, callback) {
			var image;
			function onReady () {
				if (callback) callback();
			}
			if (!imgElement.complete || !checkForComplete) {
				if (src) {
					image = new window.Image();
					image.onload = onReady;
					image.onerror = onReady;
					if (srcset) {
						image.srcset = srcset;
					}
					if (src) {
						image.src = src;
					}
				} else {
					onReady();
				}
				
			} else {//image already loaded...
				onReady();
			}
		};
		s.preloadImages = function () {
			s.imagesToLoad = s.container.find('img');
			function _onReady() {
				if (typeof s === 'undefined' || s === null) return;
				if (s.imagesLoaded !== undefined) s.imagesLoaded++;
				if (s.imagesLoaded === s.imagesToLoad.length) {
					if (s.params.updateOnImagesReady) s.update();
					s.emit('onImagesReady', s);
				}
			}
			for (var i = 0; i < s.imagesToLoad.length; i++) {
				s.loadImage(s.imagesToLoad[i], (s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute('src')), (s.imagesToLoad[i].srcset || s.imagesToLoad[i].getAttribute('srcset')), true, _onReady);
			}
		};
		
		/*=========================
		 Autoplay
		 ===========================*/
		s.autoplayTimeoutId = undefined;
		s.autoplaying = false;
		s.autoplayPaused = false;
		function autoplay() {
			s.autoplayTimeoutId = setTimeout(function () {
				if (s.params.loop) {
					s.fixLoop();
					s._slideNext();
				}
				else {
					if (!s.isEnd) {
						s._slideNext();
					}
					else {
						if (!params.autoplayStopOnLast) {
							s._slideTo(0);
						}
						else {
							s.stopAutoplay();
						}
					}
				}
			}, s.params.autoplay);
		}
		s.startAutoplay = function () {
			if (typeof s.autoplayTimeoutId !== 'undefined') return false;
			if (!s.params.autoplay) return false;
			if (s.autoplaying) return false;
			s.autoplaying = true;
			s.emit('onAutoplayStart', s);
			autoplay();
		};
		s.stopAutoplay = function (internal) {
			if (!s.autoplayTimeoutId) return;
			if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
			s.autoplaying = false;
			s.autoplayTimeoutId = undefined;
			s.emit('onAutoplayStop', s);
		};
		s.pauseAutoplay = function (speed) {
			if (s.autoplayPaused) return;
			if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
			s.autoplayPaused = true;
			if (speed === 0) {
				s.autoplayPaused = false;
				autoplay();
			}
			else {
				s.wrapper.transitionEnd(function () {
					if (!s) return;
					s.autoplayPaused = false;
					if (!s.autoplaying) {
						s.stopAutoplay();
					}
					else {
						autoplay();
					}
				});
			}
		};
		/*=========================
		 Min/Max Translate
		 ===========================*/
		s.minTranslate = function () {
			return (-s.snapGrid[0]);
		};
		s.maxTranslate = function () {
			return (-s.snapGrid[s.snapGrid.length - 1]);
		};
		/*=========================
		 Slider/slides sizes
		 ===========================*/
		s.updateAutoHeight = function () {
			// Update Height
			var newHeight = s.slides.eq(s.activeIndex)[0].offsetHeight;
			if (newHeight) s.wrapper.css('height', s.slides.eq(s.activeIndex)[0].offsetHeight + 'px');
		};
		s.updateContainerSize = function () {
			var width, height;
			if (typeof s.params.width !== 'undefined') {
				width = s.params.width;
			}
			else {
				width = s.container[0].clientWidth;
			}
			if (typeof s.params.height !== 'undefined') {
				height = s.params.height;
			}
			else {
				height = s.container[0].clientHeight;
			}
			if (width === 0 && isH() || height === 0 && !isH()) {
				return;
			}
			
			//Subtract paddings
			width = width - parseInt(s.container.css('padding-left'), 10) - parseInt(s.container.css('padding-right'), 10);
			height = height - parseInt(s.container.css('padding-top'), 10) - parseInt(s.container.css('padding-bottom'), 10);
			
			// Store values
			s.width = width;
			s.height = height;
			s.size = isH() ? s.width : s.height;
		};
		
		s.updateSlidesSize = function () {
			s.slides = s.wrapper.children('.' + s.params.slideClass);
			s.snapGrid = [];
			s.slidesGrid = [];
			s.slidesSizesGrid = [];
			
			var spaceBetween = s.params.spaceBetween,
				slidePosition = -s.params.slidesOffsetBefore,
				i,
				prevSlideSize = 0,
				index = 0;
			if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
				spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * s.size;
			}
			
			s.virtualSize = -spaceBetween;
			// reset margins
			if (s.rtl) s.slides.css({marginLeft: '', marginTop: ''});
			else s.slides.css({marginRight: '', marginBottom: ''});
			
			var slidesNumberEvenToRows;
			if (s.params.slidesPerColumn > 1) {
				if (Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn) {
					slidesNumberEvenToRows = s.slides.length;
				}
				else {
					slidesNumberEvenToRows = Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn;
				}
				if (s.params.slidesPerView !== 'auto' && s.params.slidesPerColumnFill === 'row') {
					slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, s.params.slidesPerView * s.params.slidesPerColumn);
				}
			}
			
			// Calc slides
			var slideSize;
			var slidesPerColumn = s.params.slidesPerColumn;
			var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
			var numFullColumns = slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);
			for (i = 0; i < s.slides.length; i++) {
				slideSize = 0;
				var slide = s.slides.eq(i);
				if (s.params.slidesPerColumn > 1) {
					// Set slides order
					var newSlideOrderIndex;
					var column, row;
					if (s.params.slidesPerColumnFill === 'column') {
						column = Math.floor(i / slidesPerColumn);
						row = i - column * slidesPerColumn;
						if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn-1)) {
							if (++row >= slidesPerColumn) {
								row = 0;
								column++;
							}
						}
						newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
						slide
							.css({
								'-webkit-box-ordinal-group': newSlideOrderIndex,
								'-moz-box-ordinal-group': newSlideOrderIndex,
								'-ms-flex-order': newSlideOrderIndex,
								'-webkit-order': newSlideOrderIndex,
								'order': newSlideOrderIndex
							});
					}
					else {
						row = Math.floor(i / slidesPerRow);
						column = i - row * slidesPerRow;
					}
					slide
						.css({
							'margin-top': (row !== 0 && s.params.spaceBetween) && (s.params.spaceBetween + 'px')
						})
						.attr('data-swiper-column', column)
						.attr('data-swiper-row', row);
					
				}
				if (slide.css('display') === 'none') continue;
				if (s.params.slidesPerView === 'auto') {
					slideSize = isH() ? slide.outerWidth(true) : slide.outerHeight(true);
					if (s.params.roundLengths) slideSize = round(slideSize);
				}
				else {
					slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView;
					if (s.params.roundLengths) slideSize = round(slideSize);
					
					if (isH()) {
						s.slides[i].style.width = slideSize + 'px';
					}
					else {
						s.slides[i].style.height = slideSize + 'px';
					}
				}
				s.slides[i].swiperSlideSize = slideSize;
				s.slidesSizesGrid.push(slideSize);
				
				
				if (s.params.centeredSlides) {
					slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
					if (i === 0) slidePosition = slidePosition - s.size / 2 - spaceBetween;
					if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
					if ((index) % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
					s.slidesGrid.push(slidePosition);
				}
				else {
					if ((index) % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
					s.slidesGrid.push(slidePosition);
					slidePosition = slidePosition + slideSize + spaceBetween;
				}
				
				s.virtualSize += slideSize + spaceBetween;
				
				prevSlideSize = slideSize;
				
				index ++;
			}
			s.virtualSize = Math.max(s.virtualSize, s.size) + s.params.slidesOffsetAfter;
			var newSlidesGrid;
			
			if (
				s.rtl && s.wrongRTL && (s.params.effect === 'slide' || s.params.effect === 'coverflow')) {
				s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
			}
			if (!s.support.flexbox || s.params.setWrapperSize) {
				if (isH()) s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
				else s.wrapper.css({height: s.virtualSize + s.params.spaceBetween + 'px'});
			}
			
			if (s.params.slidesPerColumn > 1) {
				s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows;
				s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween;
				s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
				if (s.params.centeredSlides) {
					newSlidesGrid = [];
					for (i = 0; i < s.snapGrid.length; i++) {
						if (s.snapGrid[i] < s.virtualSize + s.snapGrid[0]) newSlidesGrid.push(s.snapGrid[i]);
					}
					s.snapGrid = newSlidesGrid;
				}
			}
			
			// Remove last grid elements depending on width
			if (!s.params.centeredSlides) {
				newSlidesGrid = [];
				for (i = 0; i < s.snapGrid.length; i++) {
					if (s.snapGrid[i] <= s.virtualSize - s.size) {
						newSlidesGrid.push(s.snapGrid[i]);
					}
				}
				s.snapGrid = newSlidesGrid;
				if (Math.floor(s.virtualSize - s.size) > Math.floor(s.snapGrid[s.snapGrid.length - 1])) {
					s.snapGrid.push(s.virtualSize - s.size);
				}
			}
			if (s.snapGrid.length === 0) s.snapGrid = [0];
			
			if (s.params.spaceBetween !== 0) {
				if (isH()) {
					if (s.rtl) s.slides.css({marginLeft: spaceBetween + 'px'});
					else s.slides.css({marginRight: spaceBetween + 'px'});
				}
				else s.slides.css({marginBottom: spaceBetween + 'px'});
			}
			if (s.params.watchSlidesProgress) {
				s.updateSlidesOffset();
			}
		};
		s.updateSlidesOffset = function () {
			for (var i = 0; i < s.slides.length; i++) {
				s.slides[i].swiperSlideOffset = isH() ? s.slides[i].offsetLeft : s.slides[i].offsetTop;
			}
		};
		
		/*=========================
		 Slider/slides progress
		 ===========================*/
		s.updateSlidesProgress = function (translate) {
			if (typeof translate === 'undefined') {
				translate = s.translate || 0;
			}
			if (s.slides.length === 0) return;
			if (typeof s.slides[0].swiperSlideOffset === 'undefined') s.updateSlidesOffset();
			
			var offsetCenter = -translate;
			if (s.rtl) offsetCenter = translate;
			
			// Visible Slides
			s.slides.removeClass(s.params.slideVisibleClass);
			for (var i = 0; i < s.slides.length; i++) {
				var slide = s.slides[i];
				var slideProgress = (offsetCenter - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.params.spaceBetween);
				if (s.params.watchSlidesVisibility) {
					var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
					var slideAfter = slideBefore + s.slidesSizesGrid[i];
					var isVisible =
						(slideBefore >= 0 && slideBefore < s.size) ||
						(slideAfter > 0 && slideAfter <= s.size) ||
						(slideBefore <= 0 && slideAfter >= s.size);
					if (isVisible) {
						s.slides.eq(i).addClass(s.params.slideVisibleClass);
					}
				}
				slide.progress = s.rtl ? -slideProgress : slideProgress;
			}
		};
		s.updateProgress = function (translate) {
			if (typeof translate === 'undefined') {
				translate = s.translate || 0;
			}
			var translatesDiff = s.maxTranslate() - s.minTranslate();
			var wasBeginning = s.isBeginning;
			var wasEnd = s.isEnd;
			if (translatesDiff === 0) {
				s.progress = 0;
				s.isBeginning = s.isEnd = true;
			}
			else {
				s.progress = (translate - s.minTranslate()) / (translatesDiff);
				s.isBeginning = s.progress <= 0;
				s.isEnd = s.progress >= 1;
			}
			if (s.isBeginning && !wasBeginning) s.emit('onReachBeginning', s);
			if (s.isEnd && !wasEnd) s.emit('onReachEnd', s);
			
			if (s.params.watchSlidesProgress) s.updateSlidesProgress(translate);
			s.emit('onProgress', s, s.progress);
		};
		s.updateActiveIndex = function () {
			var translate = s.rtl ? s.translate : -s.translate;
			var newActiveIndex, i, snapIndex;
			for (i = 0; i < s.slidesGrid.length; i ++) {
				if (typeof s.slidesGrid[i + 1] !== 'undefined') {
					if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2) {
						newActiveIndex = i;
					}
					else if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1]) {
						newActiveIndex = i + 1;
					}
				}
				else {
					if (translate >= s.slidesGrid[i]) {
						newActiveIndex = i;
					}
				}
			}
			// Normalize slideIndex
			if (newActiveIndex < 0 || typeof newActiveIndex === 'undefined') newActiveIndex = 0;
			// for (i = 0; i < s.slidesGrid.length; i++) {
			// if (- translate >= s.slidesGrid[i]) {
			// newActiveIndex = i;
			// }
			// }
			snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup);
			if (snapIndex >= s.snapGrid.length) snapIndex = s.snapGrid.length - 1;
			
			if (newActiveIndex === s.activeIndex) {
				return;
			}
			s.snapIndex = snapIndex;
			s.previousIndex = s.activeIndex;
			s.activeIndex = newActiveIndex;
			s.updateClasses();
		};
		
		/*=========================
		 Classes
		 ===========================*/
		s.updateClasses = function () {
			s.slides.removeClass(s.params.slideActiveClass + ' ' + s.params.slideNextClass + ' ' + s.params.slidePrevClass);
			var activeSlide = s.slides.eq(s.activeIndex);
			// Active classes
			activeSlide.addClass(s.params.slideActiveClass);
			activeSlide.next('.' + s.params.slideClass).addClass(s.params.slideNextClass);
			activeSlide.prev('.' + s.params.slideClass).addClass(s.params.slidePrevClass);
			
			// Pagination
			if (s.bullets && s.bullets.length > 0) {
				s.bullets.removeClass(s.params.bulletActiveClass);
				var bulletIndex;
				if (s.params.loop) {
					bulletIndex = Math.ceil(s.activeIndex - s.loopedSlides)/s.params.slidesPerGroup;
					if (bulletIndex > s.slides.length - 1 - s.loopedSlides * 2) {
						bulletIndex = bulletIndex - (s.slides.length - s.loopedSlides * 2);
					}
					if (bulletIndex > s.bullets.length - 1) bulletIndex = bulletIndex - s.bullets.length;
				}
				else {
					if (typeof s.snapIndex !== 'undefined') {
						bulletIndex = s.snapIndex;
					}
					else {
						bulletIndex = s.activeIndex || 0;
					}
				}
				if (s.paginationContainer.length > 1) {
					s.bullets.each(function () {
						if ($(this).index() === bulletIndex) $(this).addClass(s.params.bulletActiveClass);
					});
				}
				else {
					s.bullets.eq(bulletIndex).addClass(s.params.bulletActiveClass);
				}
			}
			
			// Next/active buttons
			if (!s.params.loop) {
				if (s.params.prevButton) {
					if (s.isBeginning) {
						$(s.params.prevButton).addClass(s.params.buttonDisabledClass);
						if (s.params.a11y && s.a11y) s.a11y.disable($(s.params.prevButton));
					}
					else {
						$(s.params.prevButton).removeClass(s.params.buttonDisabledClass);
						if (s.params.a11y && s.a11y) s.a11y.enable($(s.params.prevButton));
					}
				}
				if (s.params.nextButton) {
					if (s.isEnd) {
						$(s.params.nextButton).addClass(s.params.buttonDisabledClass);
						if (s.params.a11y && s.a11y) s.a11y.disable($(s.params.nextButton));
					}
					else {
						$(s.params.nextButton).removeClass(s.params.buttonDisabledClass);
						if (s.params.a11y && s.a11y) s.a11y.enable($(s.params.nextButton));
					}
				}
			}
		};
		
		/*=========================
		 Pagination
		 ===========================*/
		s.updatePagination = function () {
			if (!s.params.pagination) return;
			if (s.paginationContainer && s.paginationContainer.length > 0) {
				var bulletsHTML = '';
				var numberOfBullets = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
				for (var i = 0; i < numberOfBullets; i++) {
					if (s.params.paginationBulletRender) {
						bulletsHTML += s.params.paginationBulletRender(i, s.params.bulletClass);
					}
					else {
						bulletsHTML += '<' + s.params.paginationElement+' class="' + s.params.bulletClass + '"></' + s.params.paginationElement + '>';
					}
				}
				s.paginationContainer.html(bulletsHTML);
				s.bullets = s.paginationContainer.find('.' + s.params.bulletClass);
				if (s.params.paginationClickable && s.params.a11y && s.a11y) {
					s.a11y.initPagination();
				}
			}
		};
		/*=========================
		 Common update method
		 ===========================*/
		s.update = function (updateTranslate) {
			s.updateContainerSize();
			s.updateSlidesSize();
			s.updateProgress();
			s.updatePagination();
			s.updateClasses();
			if (s.params.scrollbar && s.scrollbar) {
				s.scrollbar.set();
			}
			function forceSetTranslate() {
				newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
				s.setWrapperTranslate(newTranslate);
				s.updateActiveIndex();
				s.updateClasses();
			}
			if (updateTranslate) {
				var translated, newTranslate;
				if (s.controller && s.controller.spline) {
					s.controller.spline = undefined;
				}
				if (s.params.freeMode) {
					forceSetTranslate();
					if (s.params.autoHeight) {
						s.updateAutoHeight();
					}
				}
				else {
					if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
						translated = s.slideTo(s.slides.length - 1, 0, false, true);
					}
					else {
						translated = s.slideTo(s.activeIndex, 0, false, true);
					}
					if (!translated) {
						forceSetTranslate();
					}
				}
			}
			else if (s.params.autoHeight) {
				s.updateAutoHeight();
			}
		};
		
		/*=========================
		 Resize Handler
		 ===========================*/
		s.onResize = function (forceUpdatePagination) {
			//Breakpoints
			if (s.params.breakpoints) {
				s.setBreakpoint();
			}
			
			// Disable locks on resize
			var allowSwipeToPrev = s.params.allowSwipeToPrev;
			var allowSwipeToNext = s.params.allowSwipeToNext;
			s.params.allowSwipeToPrev = s.params.allowSwipeToNext = true;
			
			s.updateContainerSize();
			s.updateSlidesSize();
			if (s.params.slidesPerView === 'auto' || s.params.freeMode || forceUpdatePagination) s.updatePagination();
			if (s.params.scrollbar && s.scrollbar) {
				s.scrollbar.set();
			}
			if (s.controller && s.controller.spline) {
				s.controller.spline = undefined;
			}
			if (s.params.freeMode) {
				var newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
				s.setWrapperTranslate(newTranslate);
				s.updateActiveIndex();
				s.updateClasses();
				
				if (s.params.autoHeight) {
					s.updateAutoHeight();
				}
			}
			else {
				s.updateClasses();
				if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
					s.slideTo(s.slides.length - 1, 0, false, true);
				}
				else {
					s.slideTo(s.activeIndex, 0, false, true);
				}
			}
			// Return locks after resize
			s.params.allowSwipeToPrev = allowSwipeToPrev;
			s.params.allowSwipeToNext = allowSwipeToNext;
		};
		
		/*=========================
		 Events
		 ===========================*/
		
		//Define Touch Events
		var desktopEvents = ['mousedown', 'mousemove', 'mouseup'];
		if (window.navigator.pointerEnabled) desktopEvents = ['pointerdown', 'pointermove', 'pointerup'];
		else if (window.navigator.msPointerEnabled) desktopEvents = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
		s.touchEvents = {
			start : s.support.touch || !s.params.simulateTouch  ? 'touchstart' : desktopEvents[0],
			move : s.support.touch || !s.params.simulateTouch ? 'touchmove' : desktopEvents[1],
			end : s.support.touch || !s.params.simulateTouch ? 'touchend' : desktopEvents[2]
		};
		
		
		// WP8 Touch Events Fix
		if (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) {
			(s.params.touchEventsTarget === 'container' ? s.container : s.wrapper).addClass('swiper-wp8-' + s.params.direction);
		}
		
		// Attach/detach events
		s.initEvents = function (detach) {
			var actionDom = detach ? 'off' : 'on';
			var action = detach ? 'removeEventListener' : 'addEventListener';
			var touchEventsTarget = s.params.touchEventsTarget === 'container' ? s.container[0] : s.wrapper[0];
			var target = s.support.touch ? touchEventsTarget : document;
			
			var moveCapture = s.params.nested ? true : false;
			
			//Touch Events
			if (s.browser.ie) {
				touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
				target[action](s.touchEvents.move, s.onTouchMove, moveCapture);
				target[action](s.touchEvents.end, s.onTouchEnd, false);
			}
			else {
				if (s.support.touch) {
					touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
					touchEventsTarget[action](s.touchEvents.move, s.onTouchMove, moveCapture);
					touchEventsTarget[action](s.touchEvents.end, s.onTouchEnd, false);
				}
				if (params.simulateTouch && !s.device.ios && !s.device.android) {
					touchEventsTarget[action]('mousedown', s.onTouchStart, false);
					document[action]('mousemove', s.onTouchMove, moveCapture);
					document[action]('mouseup', s.onTouchEnd, false);
				}
			}
			window[action]('resize', s.onResize);
			
			// Next, Prev, Index
			if (s.params.nextButton) {
				$(s.params.nextButton)[actionDom]('click', s.onClickNext);
				if (s.params.a11y && s.a11y) $(s.params.nextButton)[actionDom]('keydown', s.a11y.onEnterKey);
			}
			if (s.params.prevButton) {
				$(s.params.prevButton)[actionDom]('click', s.onClickPrev);
				if (s.params.a11y && s.a11y) $(s.params.prevButton)[actionDom]('keydown', s.a11y.onEnterKey);
			}
			if (s.params.pagination && s.params.paginationClickable) {
				$(s.paginationContainer)[actionDom]('click', '.' + s.params.bulletClass, s.onClickIndex);
				if (s.params.a11y && s.a11y) $(s.paginationContainer)[actionDom]('keydown', '.' + s.params.bulletClass, s.a11y.onEnterKey);
			}
			
			// Prevent Links Clicks
			if (s.params.preventClicks || s.params.preventClicksPropagation) touchEventsTarget[action]('click', s.preventClicks, true);
		};
		s.attachEvents = function (detach) {
			s.initEvents();
		};
		s.detachEvents = function () {
			s.initEvents(true);
		};
		
		/*=========================
		 Handle Clicks
		 ===========================*/
		// Prevent Clicks
		s.allowClick = true;
		s.preventClicks = function (e) {
			if (!s.allowClick) {
				if (s.params.preventClicks) e.preventDefault();
				if (s.params.preventClicksPropagation && s.animating) {
					e.stopPropagation();
					e.stopImmediatePropagation();
				}
			}
		};
		// Clicks
		s.onClickNext = function (e) {
			e.preventDefault();
			if (s.isEnd && !s.params.loop) return;
			s.slideNext();
		};
		s.onClickPrev = function (e) {
			e.preventDefault();
			if (s.isBeginning && !s.params.loop) return;
			s.slidePrev();
		};
		s.onClickIndex = function (e) {
			e.preventDefault();
			var index = $(this).index() * s.params.slidesPerGroup;
			if (s.params.loop) index = index + s.loopedSlides;
			s.slideTo(index);
		};
		
		/*=========================
		 Handle Touches
		 ===========================*/
		function findElementInEvent(e, selector) {
			var el = $(e.target);
			if (!el.is(selector)) {
				if (typeof selector === 'string') {
					el = el.parents(selector);
				}
				else if (selector.nodeType) {
					var found;
					el.parents().each(function (index, _el) {
						if (_el === selector) found = selector;
					});
					if (!found) return undefined;
					else return selector;
				}
			}
			if (el.length === 0) {
				return undefined;
			}
			return el[0];
		}
		s.updateClickedSlide = function (e) {
			var slide = findElementInEvent(e, '.' + s.params.slideClass);
			var slideFound = false;
			if (slide) {
				for (var i = 0; i < s.slides.length; i++) {
					if (s.slides[i] === slide) slideFound = true;
				}
			}
			
			if (slide && slideFound) {
				s.clickedSlide = slide;
				s.clickedIndex = $(slide).index();
			}
			else {
				s.clickedSlide = undefined;
				s.clickedIndex = undefined;
				return;
			}
			if (s.params.slideToClickedSlide && s.clickedIndex !== undefined && s.clickedIndex !== s.activeIndex) {
				var slideToIndex = s.clickedIndex,
					realIndex,
					duplicatedSlides;
				if (s.params.loop) {
					if (s.animating) return;
					realIndex = $(s.clickedSlide).attr('data-swiper-slide-index');
					if (s.params.centeredSlides) {
						if ((slideToIndex < s.loopedSlides - s.params.slidesPerView/2) || (slideToIndex > s.slides.length - s.loopedSlides + s.params.slidesPerView/2)) {
							s.fixLoop();
							slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.swiper-slide-duplicate)').eq(0).index();
							setTimeout(function () {
								s.slideTo(slideToIndex);
							}, 0);
						}
						else {
							s.slideTo(slideToIndex);
						}
					}
					else {
						if (slideToIndex > s.slides.length - s.params.slidesPerView) {
							s.fixLoop();
							slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.swiper-slide-duplicate)').eq(0).index();
							setTimeout(function () {
								s.slideTo(slideToIndex);
							}, 0);
						}
						else {
							s.slideTo(slideToIndex);
						}
					}
				}
				else {
					s.slideTo(slideToIndex);
				}
			}
		};
		
		var isTouched,
			isMoved,
			allowTouchCallbacks,
			touchStartTime,
			isScrolling,
			currentTranslate,
			startTranslate,
			allowThresholdMove,
		// Form elements to match
			formElements = 'input, select, textarea, button',
		// Last click time
			lastClickTime = Date.now(), clickTimeout,
		//Velocities
			velocities = [],
			allowMomentumBounce;
		
		// Animating Flag
		s.animating = false;
		
		// Touches information
		s.touches = {
			startX: 0,
			startY: 0,
			currentX: 0,
			currentY: 0,
			diff: 0
		};
		
		// Touch handlers
		var isTouchEvent, startMoving;
		s.onTouchStart = function (e) {
			if (e.originalEvent) e = e.originalEvent;
			isTouchEvent = e.type === 'touchstart';
			if (!isTouchEvent && 'which' in e && e.which === 3) return;
			if (s.params.noSwiping && findElementInEvent(e, '.' + s.params.noSwipingClass)) {
				s.allowClick = true;
				return;
			}
			if (s.params.swipeHandler) {
				if (!findElementInEvent(e, s.params.swipeHandler)) return;
			}
			
			var startX = s.touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
			var startY = s.touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
			
			// Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore
			if(s.device.ios && s.params.iOSEdgeSwipeDetection && startX <= s.params.iOSEdgeSwipeThreshold) {
				return;
			}
			
			isTouched = true;
			isMoved = false;
			allowTouchCallbacks = true;
			isScrolling = undefined;
			startMoving = undefined;
			s.touches.startX = startX;
			s.touches.startY = startY;
			touchStartTime = Date.now();
			s.allowClick = true;
			s.updateContainerSize();
			s.swipeDirection = undefined;
			if (s.params.threshold > 0) allowThresholdMove = false;
			if (e.type !== 'touchstart') {
				var preventDefault = true;
				if ($(e.target).is(formElements)) preventDefault = false;
				if (document.activeElement && $(document.activeElement).is(formElements)) {
					document.activeElement.blur();
				}
				if (preventDefault) {
					e.preventDefault();
				}
			}
			s.emit('onTouchStart', s, e);
		};
		
		s.onTouchMove = function (e) {
			if (e.originalEvent) e = e.originalEvent;
			if (isTouchEvent && e.type === 'mousemove') return;
			if (e.preventedByNestedSwiper) return;
			if (s.params.onlyExternal) {
				// isMoved = true;
				s.allowClick = false;
				if (isTouched) {
					s.touches.startX = s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
					s.touches.startY = s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
					touchStartTime = Date.now();
				}
				return;
			}
			if (isTouchEvent && document.activeElement) {
				if (e.target === document.activeElement && $(e.target).is(formElements)) {
					isMoved = true;
					s.allowClick = false;
					return;
				}
			}
			if (allowTouchCallbacks) {
				s.emit('onTouchMove', s, e);
			}
			if (e.targetTouches && e.targetTouches.length > 1) return;
			
			s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
			s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
			
			if (typeof isScrolling === 'undefined') {
				var touchAngle = Math.atan2(Math.abs(s.touches.currentY - s.touches.startY), Math.abs(s.touches.currentX - s.touches.startX)) * 180 / Math.PI;
				isScrolling = isH() ? touchAngle > s.params.touchAngle : (90 - touchAngle > s.params.touchAngle);
			}
			if (isScrolling) {
				s.emit('onTouchMoveOpposite', s, e);
			}
			if (typeof startMoving === 'undefined' && s.browser.ieTouch) {
				if (s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY) {
					startMoving = true;
				}
			}
			if (!isTouched) return;
			if (isScrolling)  {
				isTouched = false;
				return;
			}
			if (!startMoving && s.browser.ieTouch) {
				return;
			}
			s.allowClick = false;
			s.emit('onSliderMove', s, e);
			e.preventDefault();
			if (s.params.touchMoveStopPropagation && !s.params.nested) {
				e.stopPropagation();
			}
			
			if (!isMoved) {
				if (params.loop) {
					s.fixLoop();
				}
				startTranslate = s.getWrapperTranslate();
				s.setWrapperTransition(0);
				if (s.animating) {
					s.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd');
				}
				if (s.params.autoplay && s.autoplaying) {
					if (s.params.autoplayDisableOnInteraction) {
						s.stopAutoplay();
					}
					else {
						s.pauseAutoplay();
					}
				}
				allowMomentumBounce = false;
				//Grab Cursor
				if (s.params.grabCursor) {
					s.container[0].style.cursor = 'move';
					s.container[0].style.cursor = '-webkit-grabbing';
					s.container[0].style.cursor = '-moz-grabbin';
					s.container[0].style.cursor = 'grabbing';
				}
			}
			isMoved = true;
			
			var diff = s.touches.diff = isH() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
			
			diff = diff * s.params.touchRatio;
			if (s.rtl) diff = -diff;
			
			s.swipeDirection = diff > 0 ? 'prev' : 'next';
			currentTranslate = diff + startTranslate;
			
			var disableParentSwiper = true;
			if ((diff > 0 && currentTranslate > s.minTranslate())) {
				disableParentSwiper = false;
				if (s.params.resistance) currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff, s.params.resistanceRatio);
			}
			else if (diff < 0 && currentTranslate < s.maxTranslate()) {
				disableParentSwiper = false;
				if (s.params.resistance) currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff, s.params.resistanceRatio);
			}
			
			if (disableParentSwiper) {
				e.preventedByNestedSwiper = true;
			}
			
			// Directions locks
			if (!s.params.allowSwipeToNext && s.swipeDirection === 'next' && currentTranslate < startTranslate) {
				currentTranslate = startTranslate;
			}
			if (!s.params.allowSwipeToPrev && s.swipeDirection === 'prev' && currentTranslate > startTranslate) {
				currentTranslate = startTranslate;
			}
			
			if (!s.params.followFinger) return;
			
			// Threshold
			if (s.params.threshold > 0) {
				if (Math.abs(diff) > s.params.threshold || allowThresholdMove) {
					if (!allowThresholdMove) {
						allowThresholdMove = true;
						s.touches.startX = s.touches.currentX;
						s.touches.startY = s.touches.currentY;
						currentTranslate = startTranslate;
						s.touches.diff = isH() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
						return;
					}
				}
				else {
					currentTranslate = startTranslate;
					return;
				}
			}
			// Update active index in free mode
			if (s.params.freeMode || s.params.watchSlidesProgress) {
				s.updateActiveIndex();
			}
			if (s.params.freeMode) {
				//Velocity
				if (velocities.length === 0) {
					velocities.push({
						position: s.touches[isH() ? 'startX' : 'startY'],
						time: touchStartTime
					});
				}
				velocities.push({
					position: s.touches[isH() ? 'currentX' : 'currentY'],
					time: (new window.Date()).getTime()
				});
			}
			// Update progress
			s.updateProgress(currentTranslate);
			// Update translate
			s.setWrapperTranslate(currentTranslate);
		};
		s.onTouchEnd = function (e) {
			if (e.originalEvent) e = e.originalEvent;
			if (allowTouchCallbacks) {
				s.emit('onTouchEnd', s, e);
			}
			allowTouchCallbacks = false;
			if (!isTouched) return;
			//Return Grab Cursor
			if (s.params.grabCursor && isMoved && isTouched) {
				s.container[0].style.cursor = 'move';
				s.container[0].style.cursor = '-webkit-grab';
				s.container[0].style.cursor = '-moz-grab';
				s.container[0].style.cursor = 'grab';
			}
			
			// Time diff
			var touchEndTime = Date.now();
			var timeDiff = touchEndTime - touchStartTime;
			
			// Tap, doubleTap, Click
			if (s.allowClick) {
				s.updateClickedSlide(e);
				s.emit('onTap', s, e);
				if (timeDiff < 300 && (touchEndTime - lastClickTime) > 300) {
					if (clickTimeout) clearTimeout(clickTimeout);
					clickTimeout = setTimeout(function () {
						if (!s) return;
						if (s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass)) {
							s.paginationContainer.toggleClass(s.params.paginationHiddenClass);
						}
						s.emit('onClick', s, e);
					}, 300);
					
				}
				if (timeDiff < 300 && (touchEndTime - lastClickTime) < 300) {
					if (clickTimeout) clearTimeout(clickTimeout);
					s.emit('onDoubleTap', s, e);
				}
			}
			
			lastClickTime = Date.now();
			setTimeout(function () {
				if (s) s.allowClick = true;
			}, 0);
			
			if (!isTouched || !isMoved || !s.swipeDirection || s.touches.diff === 0 || currentTranslate === startTranslate) {
				isTouched = isMoved = false;
				return;
			}
			isTouched = isMoved = false;
			
			var currentPos;
			if (s.params.followFinger) {
				currentPos = s.rtl ? s.translate : -s.translate;
			}
			else {
				currentPos = -currentTranslate;
			}
			if (s.params.freeMode) {
				if (currentPos < -s.minTranslate()) {
					s.slideTo(s.activeIndex);
					return;
				}
				else if (currentPos > -s.maxTranslate()) {
					if (s.slides.length < s.snapGrid.length) {
						s.slideTo(s.snapGrid.length - 1);
					}
					else {
						s.slideTo(s.slides.length - 1);
					}
					return;
				}
				
				if (s.params.freeModeMomentum) {
					if (velocities.length > 1) {
						var lastMoveEvent = velocities.pop(), velocityEvent = velocities.pop();
						
						var distance = lastMoveEvent.position - velocityEvent.position;
						var time = lastMoveEvent.time - velocityEvent.time;
						s.velocity = distance / time;
						s.velocity = s.velocity / 2;
						if (Math.abs(s.velocity) < s.params.freeModeMinimumVelocity) {
							s.velocity = 0;
						}
						// this implies that the user stopped moving a finger then released.
						// There would be no events with distance zero, so the last event is stale.
						if (time > 150 || (new window.Date().getTime() - lastMoveEvent.time) > 300) {
							s.velocity = 0;
						}
					} else {
						s.velocity = 0;
					}
					
					velocities.length = 0;
					var momentumDuration = 1000 * s.params.freeModeMomentumRatio;
					var momentumDistance = s.velocity * momentumDuration;
					
					var newPosition = s.translate + momentumDistance;
					if (s.rtl) newPosition = - newPosition;
					var doBounce = false;
					var afterBouncePosition;
					var bounceAmount = Math.abs(s.velocity) * 20 * s.params.freeModeMomentumBounceRatio;
					if (newPosition < s.maxTranslate()) {
						if (s.params.freeModeMomentumBounce) {
							if (newPosition + s.maxTranslate() < -bounceAmount) {
								newPosition = s.maxTranslate() - bounceAmount;
							}
							afterBouncePosition = s.maxTranslate();
							doBounce = true;
							allowMomentumBounce = true;
						}
						else {
							newPosition = s.maxTranslate();
						}
					}
					else if (newPosition > s.minTranslate()) {
						if (s.params.freeModeMomentumBounce) {
							if (newPosition - s.minTranslate() > bounceAmount) {
								newPosition = s.minTranslate() + bounceAmount;
							}
							afterBouncePosition = s.minTranslate();
							doBounce = true;
							allowMomentumBounce = true;
						}
						else {
							newPosition = s.minTranslate();
						}
					}
					else if (s.params.freeModeSticky) {
						var j = 0,
							nextSlide;
						for (j = 0; j < s.snapGrid.length; j += 1) {
							if (s.snapGrid[j] > -newPosition) {
								nextSlide = j;
								break;
							}
							
						}
						if (Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || s.swipeDirection === 'next') {
							newPosition = s.snapGrid[nextSlide];
						} else {
							newPosition = s.snapGrid[nextSlide - 1];
						}
						if (!s.rtl) newPosition = - newPosition;
					}
					//Fix duration
					if (s.velocity !== 0) {
						if (s.rtl) {
							momentumDuration = Math.abs((-newPosition - s.translate) / s.velocity);
						}
						else {
							momentumDuration = Math.abs((newPosition - s.translate) / s.velocity);
						}
					}
					else if (s.params.freeModeSticky) {
						s.slideReset();
						return;
					}
					
					if (s.params.freeModeMomentumBounce && doBounce) {
						s.updateProgress(afterBouncePosition);
						s.setWrapperTransition(momentumDuration);
						s.setWrapperTranslate(newPosition);
						s.onTransitionStart();
						s.animating = true;
						s.wrapper.transitionEnd(function () {
							if (!s || !allowMomentumBounce) return;
							s.emit('onMomentumBounce', s);
							
							s.setWrapperTransition(s.params.speed);
							s.setWrapperTranslate(afterBouncePosition);
							s.wrapper.transitionEnd(function () {
								if (!s) return;
								s.onTransitionEnd();
							});
						});
					} else if (s.velocity) {
						s.updateProgress(newPosition);
						s.setWrapperTransition(momentumDuration);
						s.setWrapperTranslate(newPosition);
						s.onTransitionStart();
						if (!s.animating) {
							s.animating = true;
							s.wrapper.transitionEnd(function () {
								if (!s) return;
								s.onTransitionEnd();
							});
						}
						
					} else {
						s.updateProgress(newPosition);
					}
					
					s.updateActiveIndex();
				}
				if (!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs) {
					s.updateProgress();
					s.updateActiveIndex();
				}
				return;
			}
			
			// Find current slide
			var i, stopIndex = 0, groupSize = s.slidesSizesGrid[0];
			for (i = 0; i < s.slidesGrid.length; i += s.params.slidesPerGroup) {
				if (typeof s.slidesGrid[i + s.params.slidesPerGroup] !== 'undefined') {
					if (currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup]) {
						stopIndex = i;
						groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i];
					}
				}
				else {
					if (currentPos >= s.slidesGrid[i]) {
						stopIndex = i;
						groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2];
					}
				}
			}
			
			// Find current slide size
			var ratio = (currentPos - s.slidesGrid[stopIndex]) / groupSize;
			
			if (timeDiff > s.params.longSwipesMs) {
				// Long touches
				if (!s.params.longSwipes) {
					s.slideTo(s.activeIndex);
					return;
				}
				if (s.swipeDirection === 'next') {
					if (ratio >= s.params.longSwipesRatio) s.slideTo(stopIndex + s.params.slidesPerGroup);
					else s.slideTo(stopIndex);
					
				}
				if (s.swipeDirection === 'prev') {
					if (ratio > (1 - s.params.longSwipesRatio)) s.slideTo(stopIndex + s.params.slidesPerGroup);
					else s.slideTo(stopIndex);
				}
			}
			else {
				// Short swipes
				if (!s.params.shortSwipes) {
					s.slideTo(s.activeIndex);
					return;
				}
				if (s.swipeDirection === 'next') {
					s.slideTo(stopIndex + s.params.slidesPerGroup);
					
				}
				if (s.swipeDirection === 'prev') {
					s.slideTo(stopIndex);
				}
			}
		};
		/*=========================
		 Transitions
		 ===========================*/
		s._slideTo = function (slideIndex, speed) {
			return s.slideTo(slideIndex, speed, true, true);
		};
		s.slideTo = function (slideIndex, speed, runCallbacks, internal) {
			if (typeof runCallbacks === 'undefined') runCallbacks = true;
			if (typeof slideIndex === 'undefined') slideIndex = 0;
			if (slideIndex < 0) slideIndex = 0;
			s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup);
			if (s.snapIndex >= s.snapGrid.length) s.snapIndex = s.snapGrid.length - 1;
			
			var translate = - s.snapGrid[s.snapIndex];
			
			// Stop autoplay
			if (s.params.autoplay && s.autoplaying) {
				if (internal || !s.params.autoplayDisableOnInteraction) {
					s.pauseAutoplay(speed);
				}
				else {
					s.stopAutoplay();
				}
			}
			// Update progress
			s.updateProgress(translate);
			
			// Normalize slideIndex
			for (var i = 0; i < s.slidesGrid.length; i++) {
				if (- Math.floor(translate * 100) >= Math.floor(s.slidesGrid[i] * 100)) {
					slideIndex = i;
				}
			}
			
			// Directions locks
			if (!s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate()) {
				return false;
			}
			if (!s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate()) {
				if ((s.activeIndex || 0) !== slideIndex ) return false;
			}
			
			// Update Index
			if (typeof speed === 'undefined') speed = s.params.speed;
			s.previousIndex = s.activeIndex || 0;
			s.activeIndex = slideIndex;
			
			// Update Height
			if (s.params.autoHeight) {
				s.updateAutoHeight();
			}
			
			if (translate === s.translate) {
				s.updateClasses();
				if (s.params.effect !== 'slide') {
					s.setWrapperTranslate(translate);
				}
				return false;
			}
			s.updateClasses();
			s.onTransitionStart(runCallbacks);
			
			if (speed === 0) {
				s.setWrapperTransition(0);
				s.setWrapperTranslate(translate);
				s.onTransitionEnd(runCallbacks);
			}
			else {
				s.setWrapperTransition(speed);
				s.setWrapperTranslate(translate);
				if (!s.animating) {
					s.animating = true;
					s.wrapper.transitionEnd(function () {
						if (!s) return;
						s.onTransitionEnd(runCallbacks);
					});
				}
				
			}
			
			return true;
		};
		
		s.onTransitionStart = function (runCallbacks) {
			if (typeof runCallbacks === 'undefined') runCallbacks = true;
			if (s.lazy) s.lazy.onTransitionStart();
			if (runCallbacks) {
				s.emit('onTransitionStart', s);
				if (s.activeIndex !== s.previousIndex) {
					s.emit('onSlideChangeStart', s);
					if (s.activeIndex > s.previousIndex) {
						s.emit('onSlideNextStart', s);
					}
					else {
						s.emit('onSlidePrevStart', s);
					}
				}
				
			}
		};
		s.onTransitionEnd = function (runCallbacks) {
			s.animating = false;
			s.setWrapperTransition(0);
			if (typeof runCallbacks === 'undefined') runCallbacks = true;
			if (s.lazy) s.lazy.onTransitionEnd();
			if (runCallbacks) {
				s.emit('onTransitionEnd', s);
				if (s.activeIndex !== s.previousIndex) {
					s.emit('onSlideChangeEnd', s);
					if (s.activeIndex > s.previousIndex) {
						s.emit('onSlideNextEnd', s);
					}
					else {
						s.emit('onSlidePrevEnd', s);
					}
				}
			}
			if (s.params.hashnav && s.hashnav) {
				s.hashnav.setHash();
			}
			
		};
		s.slideNext = function (runCallbacks, speed, internal) {
			if (s.params.loop) {
				if (s.animating) return false;
				s.fixLoop();
				var clientLeft = s.container[0].clientLeft;
				return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
			}
			else return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
		};
		s._slideNext = function (speed) {
			return s.slideNext(true, speed, true);
		};
		s.slidePrev = function (runCallbacks, speed, internal) {
			if (s.params.loop) {
				if (s.animating) return false;
				s.fixLoop();
				var clientLeft = s.container[0].clientLeft;
				return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
			}
			else return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
		};
		s._slidePrev = function (speed) {
			return s.slidePrev(true, speed, true);
		};
		s.slideReset = function (runCallbacks, speed, internal) {
			return s.slideTo(s.activeIndex, speed, runCallbacks);
		};
		
		/*=========================
		 Translate/transition helpers
		 ===========================*/
		s.setWrapperTransition = function (duration, byController) {
			s.wrapper.transition(duration);
			if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
				s.effects[s.params.effect].setTransition(duration);
			}
			if (s.params.parallax && s.parallax) {
				s.parallax.setTransition(duration);
			}
			if (s.params.scrollbar && s.scrollbar) {
				s.scrollbar.setTransition(duration);
			}
			if (s.params.control && s.controller) {
				s.controller.setTransition(duration, byController);
			}
			s.emit('onSetTransition', s, duration);
		};
		s.setWrapperTranslate = function (translate, updateActiveIndex, byController) {
			var x = 0, y = 0, z = 0;
			if (isH()) {
				x = s.rtl ? -translate : translate;
			}
			else {
				y = translate;
			}
			
			if (s.params.roundLengths) {
				x = round(x);
				y = round(y);
			}
			
			if (!s.params.virtualTranslate) {
				if (s.support.transforms3d) s.wrapper.transform('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');
				else s.wrapper.transform('translate(' + x + 'px, ' + y + 'px)');
			}
			
			s.translate = isH() ? x : y;
			
			// Check if we need to update progress
			var progress;
			var translatesDiff = s.maxTranslate() - s.minTranslate();
			if (translatesDiff === 0) {
				progress = 0;
			}
			else {
				progress = (translate - s.minTranslate()) / (translatesDiff);
			}
			if (progress !== s.progress) {
				s.updateProgress(translate);
			}
			
			if (updateActiveIndex) s.updateActiveIndex();
			if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
				s.effects[s.params.effect].setTranslate(s.translate);
			}
			if (s.params.parallax && s.parallax) {
				s.parallax.setTranslate(s.translate);
			}
			if (s.params.scrollbar && s.scrollbar) {
				s.scrollbar.setTranslate(s.translate);
			}
			if (s.params.control && s.controller) {
				s.controller.setTranslate(s.translate, byController);
			}
			s.emit('onSetTranslate', s, s.translate);
		};
		
		s.getTranslate = function (el, axis) {
			var matrix, curTransform, curStyle, transformMatrix;
			
			// automatic axis detection
			if (typeof axis === 'undefined') {
				axis = 'x';
			}
			
			if (s.params.virtualTranslate) {
				return s.rtl ? -s.translate : s.translate;
			}
			
			curStyle = window.getComputedStyle(el, null);
			if (window.WebKitCSSMatrix) {
				curTransform = curStyle.transform || curStyle.webkitTransform;
				if (curTransform.split(',').length > 6) {
					curTransform = curTransform.split(', ').map(function(a){
						return a.replace(',','.');
					}).join(', ');
				}
				// Some old versions of Webkit choke when 'none' is passed; pass
				// empty string instead in this case
				transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
			}
			else {
				transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform  || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
				matrix = transformMatrix.toString().split(',');
			}
			
			if (axis === 'x') {
				//Latest Chrome and webkits Fix
				if (window.WebKitCSSMatrix)
					curTransform = transformMatrix.m41;
				//Crazy IE10 Matrix
				else if (matrix.length === 16)
					curTransform = parseFloat(matrix[12]);
				//Normal Browsers
				else
					curTransform = parseFloat(matrix[4]);
			}
			if (axis === 'y') {
				//Latest Chrome and webkits Fix
				if (window.WebKitCSSMatrix)
					curTransform = transformMatrix.m42;
				//Crazy IE10 Matrix
				else if (matrix.length === 16)
					curTransform = parseFloat(matrix[13]);
				//Normal Browsers
				else
					curTransform = parseFloat(matrix[5]);
			}
			if (s.rtl && curTransform) curTransform = -curTransform;
			return curTransform || 0;
		};
		s.getWrapperTranslate = function (axis) {
			if (typeof axis === 'undefined') {
				axis = isH() ? 'x' : 'y';
			}
			return s.getTranslate(s.wrapper[0], axis);
		};
		
		/*=========================
		 Observer
		 ===========================*/
		s.observers = [];
		function initObserver(target, options) {
			options = options || {};
			// create an observer instance
			var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
			var observer = new ObserverFunc(function (mutations) {
				mutations.forEach(function (mutation) {
					s.onResize(true);
					s.emit('onObserverUpdate', s, mutation);
				});
			});
			
			observer.observe(target, {
				attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
				childList: typeof options.childList === 'undefined' ? true : options.childList,
				characterData: typeof options.characterData === 'undefined' ? true : options.characterData
			});
			
			s.observers.push(observer);
		}
		s.initObservers = function () {
			if (s.params.observeParents) {
				var containerParents = s.container.parents();
				for (var i = 0; i < containerParents.length; i++) {
					initObserver(containerParents[i]);
				}
			}
			
			// Observe container
			initObserver(s.container[0], {childList: false});
			
			// Observe wrapper
			initObserver(s.wrapper[0], {attributes: false});
		};
		s.disconnectObservers = function () {
			for (var i = 0; i < s.observers.length; i++) {
				s.observers[i].disconnect();
			}
			s.observers = [];
		};
		/*=========================
		 Loop
		 ===========================*/
		// Create looped slides
		s.createLoop = function () {
			// Remove duplicated slides
			s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
			
			var slides = s.wrapper.children('.' + s.params.slideClass);
			
			if(s.params.slidesPerView === 'auto' && !s.params.loopedSlides) s.params.loopedSlides = slides.length;
			
			s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView, 10);
			s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides;
			if (s.loopedSlides > slides.length) {
				s.loopedSlides = slides.length;
			}
			
			var prependSlides = [], appendSlides = [], i;
			slides.each(function (index, el) {
				var slide = $(this);
				if (index < s.loopedSlides) appendSlides.push(el);
				if (index < slides.length && index >= slides.length - s.loopedSlides) prependSlides.push(el);
				slide.attr('data-swiper-slide-index', index);
			});
			for (i = 0; i < appendSlides.length; i++) {
				s.wrapper.append($(appendSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
			}
			for (i = prependSlides.length - 1; i >= 0; i--) {
				s.wrapper.prepend($(prependSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
			}
		};
		s.destroyLoop = function () {
			s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
			s.slides.removeAttr('data-swiper-slide-index');
		};
		s.fixLoop = function () {
			var newIndex;
			//Fix For Negative Oversliding
			if (s.activeIndex < s.loopedSlides) {
				newIndex = s.slides.length - s.loopedSlides * 3 + s.activeIndex;
				newIndex = newIndex + s.loopedSlides;
				s.slideTo(newIndex, 0, false, true);
			}
			//Fix For Positive Oversliding
			else if ((s.params.slidesPerView === 'auto' && s.activeIndex >= s.loopedSlides * 2) || (s.activeIndex > s.slides.length - s.params.slidesPerView * 2)) {
				newIndex = -s.slides.length + s.activeIndex + s.loopedSlides;
				newIndex = newIndex + s.loopedSlides;
				s.slideTo(newIndex, 0, false, true);
			}
		};
		/*=========================
		 Append/Prepend/Remove Slides
		 ===========================*/
		s.appendSlide = function (slides) {
			if (s.params.loop) {
				s.destroyLoop();
			}
			if (typeof slides === 'object' && slides.length) {
				for (var i = 0; i < slides.length; i++) {
					if (slides[i]) s.wrapper.append(slides[i]);
				}
			}
			else {
				s.wrapper.append(slides);
			}
			if (s.params.loop) {
				s.createLoop();
			}
			if (!(s.params.observer && s.support.observer)) {
				s.update(true);
			}
		};
		s.prependSlide = function (slides) {
			if (s.params.loop) {
				s.destroyLoop();
			}
			var newActiveIndex = s.activeIndex + 1;
			if (typeof slides === 'object' && slides.length) {
				for (var i = 0; i < slides.length; i++) {
					if (slides[i]) s.wrapper.prepend(slides[i]);
				}
				newActiveIndex = s.activeIndex + slides.length;
			}
			else {
				s.wrapper.prepend(slides);
			}
			if (s.params.loop) {
				s.createLoop();
			}
			if (!(s.params.observer && s.support.observer)) {
				s.update(true);
			}
			s.slideTo(newActiveIndex, 0, false);
		};
		s.removeSlide = function (slidesIndexes) {
			if (s.params.loop) {
				s.destroyLoop();
				s.slides = s.wrapper.children('.' + s.params.slideClass);
			}
			var newActiveIndex = s.activeIndex,
				indexToRemove;
			if (typeof slidesIndexes === 'object' && slidesIndexes.length) {
				for (var i = 0; i < slidesIndexes.length; i++) {
					indexToRemove = slidesIndexes[i];
					if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
					if (indexToRemove < newActiveIndex) newActiveIndex--;
				}
				newActiveIndex = Math.max(newActiveIndex, 0);
			}
			else {
				indexToRemove = slidesIndexes;
				if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
				if (indexToRemove < newActiveIndex) newActiveIndex--;
				newActiveIndex = Math.max(newActiveIndex, 0);
			}
			
			if (s.params.loop) {
				s.createLoop();
			}
			
			if (!(s.params.observer && s.support.observer)) {
				s.update(true);
			}
			if (s.params.loop) {
				s.slideTo(newActiveIndex + s.loopedSlides, 0, false);
			}
			else {
				s.slideTo(newActiveIndex, 0, false);
			}
			
		};
		s.removeAllSlides = function () {
			var slidesIndexes = [];
			for (var i = 0; i < s.slides.length; i++) {
				slidesIndexes.push(i);
			}
			s.removeSlide(slidesIndexes);
		};
		
		
		/*=========================
		 Effects
		 ===========================*/
		s.effects = {
			fade: {
				setTranslate: function () {
					for (var i = 0; i < s.slides.length; i++) {
						var slide = s.slides.eq(i);
						var offset = slide[0].swiperSlideOffset;
						var tx = -offset;
						if (!s.params.virtualTranslate) tx = tx - s.translate;
						var ty = 0;
						if (!isH()) {
							ty = tx;
							tx = 0;
						}
						var slideOpacity = s.params.fade.crossFade ?
							Math.max(1 - Math.abs(slide[0].progress), 0) :
						1 + Math.min(Math.max(slide[0].progress, -1), 0);
						slide
							.css({
								opacity: slideOpacity
							})
							.transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px)');
						
					}
					
				},
				setTransition: function (duration) {
					s.slides.transition(duration);
					if (s.params.virtualTranslate && duration !== 0) {
						var eventTriggered = false;
						s.slides.transitionEnd(function () {
							if (eventTriggered) return;
							if (!s) return;
							eventTriggered = true;
							s.animating = false;
							var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
							for (var i = 0; i < triggerEvents.length; i++) {
								s.wrapper.trigger(triggerEvents[i]);
							}
						});
					}
				}
			},
			cube: {
				setTranslate: function () {
					var wrapperRotate = 0, cubeShadow;
					if (s.params.cube.shadow) {
						if (isH()) {
							cubeShadow = s.wrapper.find('.swiper-cube-shadow');
							if (cubeShadow.length === 0) {
								cubeShadow = $('<div class="swiper-cube-shadow"></div>');
								s.wrapper.append(cubeShadow);
							}
							cubeShadow.css({height: s.width + 'px'});
						}
						else {
							cubeShadow = s.container.find('.swiper-cube-shadow');
							if (cubeShadow.length === 0) {
								cubeShadow = $('<div class="swiper-cube-shadow"></div>');
								s.container.append(cubeShadow);
							}
						}
					}
					for (var i = 0; i < s.slides.length; i++) {
						var slide = s.slides.eq(i);
						var slideAngle = i * 90;
						var round = Math.floor(slideAngle / 360);
						if (s.rtl) {
							slideAngle = -slideAngle;
							round = Math.floor(-slideAngle / 360);
						}
						var progress = Math.max(Math.min(slide[0].progress, 1), -1);
						var tx = 0, ty = 0, tz = 0;
						if (i % 4 === 0) {
							tx = - round * 4 * s.size;
							tz = 0;
						}
						else if ((i - 1) % 4 === 0) {
							tx = 0;
							tz = - round * 4 * s.size;
						}
						else if ((i - 2) % 4 === 0) {
							tx = s.size + round * 4 * s.size;
							tz = s.size;
						}
						else if ((i - 3) % 4 === 0) {
							tx = - s.size;
							tz = 3 * s.size + s.size * 4 * round;
						}
						if (s.rtl) {
							tx = -tx;
						}
						
						if (!isH()) {
							ty = tx;
							tx = 0;
						}
						
						var transform = 'rotateX(' + (isH() ? 0 : -slideAngle) + 'deg) rotateY(' + (isH() ? slideAngle : 0) + 'deg) translate3d(' + tx + 'px, ' + ty + 'px, ' + tz + 'px)';
						if (progress <= 1 && progress > -1) {
							wrapperRotate = i * 90 + progress * 90;
							if (s.rtl) wrapperRotate = -i * 90 - progress * 90;
						}
						slide.transform(transform);
						if (s.params.cube.slideShadows) {
							//Set shadows
							var shadowBefore = isH() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
							var shadowAfter = isH() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
							if (shadowBefore.length === 0) {
								shadowBefore = $('<div class="swiper-slide-shadow-' + (isH() ? 'left' : 'top') + '"></div>');
								slide.append(shadowBefore);
							}
							if (shadowAfter.length === 0) {
								shadowAfter = $('<div class="swiper-slide-shadow-' + (isH() ? 'right' : 'bottom') + '"></div>');
								slide.append(shadowAfter);
							}
							var shadowOpacity = slide[0].progress;
							if (shadowBefore.length) shadowBefore[0].style.opacity = -slide[0].progress;
							if (shadowAfter.length) shadowAfter[0].style.opacity = slide[0].progress;
						}
					}
					s.wrapper.css({
						'-webkit-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
						'-moz-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
						'-ms-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
						'transform-origin': '50% 50% -' + (s.size / 2) + 'px'
					});
					
					if (s.params.cube.shadow) {
						if (isH()) {
							cubeShadow.transform('translate3d(0px, ' + (s.width / 2 + s.params.cube.shadowOffset) + 'px, ' + (-s.width / 2) + 'px) rotateX(90deg) rotateZ(0deg) scale(' + (s.params.cube.shadowScale) + ')');
						}
						else {
							var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
							var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
							var scale1 = s.params.cube.shadowScale,
								scale2 = s.params.cube.shadowScale / multiplier,
								offset = s.params.cube.shadowOffset;
							cubeShadow.transform('scale3d(' + scale1 + ', 1, ' + scale2 + ') translate3d(0px, ' + (s.height / 2 + offset) + 'px, ' + (-s.height / 2 / scale2) + 'px) rotateX(-90deg)');
						}
					}
					var zFactor = (s.isSafari || s.isUiWebView) ? (-s.size / 2) : 0;
					s.wrapper.transform('translate3d(0px,0,' + zFactor + 'px) rotateX(' + (isH() ? 0 : wrapperRotate) + 'deg) rotateY(' + (isH() ? -wrapperRotate : 0) + 'deg)');
				},
				setTransition: function (duration) {
					s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
					if (s.params.cube.shadow && !isH()) {
						s.container.find('.swiper-cube-shadow').transition(duration);
					}
				}
			},
			coverflow: {
				setTranslate: function () {
					var transform = s.translate;
					var center = isH() ? -transform + s.width / 2 : -transform + s.height / 2;
					var rotate = isH() ? s.params.coverflow.rotate: -s.params.coverflow.rotate;
					var translate = s.params.coverflow.depth;
					//Each slide offset from center
					for (var i = 0, length = s.slides.length; i < length; i++) {
						var slide = s.slides.eq(i);
						var slideSize = s.slidesSizesGrid[i];
						var slideOffset = slide[0].swiperSlideOffset;
						var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier;
						
						var rotateY = isH() ? rotate * offsetMultiplier : 0;
						var rotateX = isH() ? 0 : rotate * offsetMultiplier;
						// var rotateZ = 0
						var translateZ = -translate * Math.abs(offsetMultiplier);
						
						var translateY = isH() ? 0 : s.params.coverflow.stretch * (offsetMultiplier);
						var translateX = isH() ? s.params.coverflow.stretch * (offsetMultiplier) : 0;
						
						//Fix for ultra small values
						if (Math.abs(translateX) < 0.001) translateX = 0;
						if (Math.abs(translateY) < 0.001) translateY = 0;
						if (Math.abs(translateZ) < 0.001) translateZ = 0;
						if (Math.abs(rotateY) < 0.001) rotateY = 0;
						if (Math.abs(rotateX) < 0.001) rotateX = 0;
						
						var slideTransform = 'translate3d(' + translateX + 'px,' + translateY + 'px,' + translateZ + 'px)  rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';
						
						slide.transform(slideTransform);
						slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
						if (s.params.coverflow.slideShadows) {
							//Set shadows
							var shadowBefore = isH() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
							var shadowAfter = isH() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
							if (shadowBefore.length === 0) {
								shadowBefore = $('<div class="swiper-slide-shadow-' + (isH() ? 'left' : 'top') + '"></div>');
								slide.append(shadowBefore);
							}
							if (shadowAfter.length === 0) {
								shadowAfter = $('<div class="swiper-slide-shadow-' + (isH() ? 'right' : 'bottom') + '"></div>');
								slide.append(shadowAfter);
							}
							if (shadowBefore.length) shadowBefore[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
							if (shadowAfter.length) shadowAfter[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
						}
					}
					
					//Set correct perspective for IE10
					if (s.browser.ie) {
						var ws = s.wrapper[0].style;
						ws.perspectiveOrigin = center + 'px 50%';
					}
				},
				setTransition: function (duration) {
					s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
				}
			}
		};
		
		/*=========================
		 Images Lazy Loading
		 ===========================*/
		s.lazy = {
			initialImageLoaded: false,
			loadImageInSlide: function (index, loadInDuplicate) {
				if (typeof index === 'undefined') return;
				if (typeof loadInDuplicate === 'undefined') loadInDuplicate = true;
				if (s.slides.length === 0) return;
				
				var slide = s.slides.eq(index);
				var img = slide.find('.swiper-lazy:not(.swiper-lazy-loaded):not(.swiper-lazy-loading)');
				if (slide.hasClass('swiper-lazy') && !slide.hasClass('swiper-lazy-loaded') && !slide.hasClass('swiper-lazy-loading')) {
					img = img.add(slide[0]);
				}
				if (img.length === 0) return;
				
				img.each(function () {
					var _img = $(this);
					_img.addClass('swiper-lazy-loading');
					var background = _img.attr('data-background');
					var src = _img.attr('data-src'),
						srcset = _img.attr('data-srcset');
					s.loadImage(_img[0], (src || background), srcset, false, function () {
						if (background) {
							_img.css('background-image', 'url(' + background + ')');
							_img.removeAttr('data-background');
						}
						else {
							if (srcset) {
								_img.attr('srcset', srcset);
								_img.removeAttr('data-srcset');
							}
							if (src) {
								_img.attr('src', src);
								_img.removeAttr('data-src');
							}
							
						}
						
						_img.addClass('swiper-lazy-loaded').removeClass('swiper-lazy-loading');
						slide.find('.swiper-lazy-preloader, .preloader').remove();
						if (s.params.loop && loadInDuplicate) {
							var slideOriginalIndex = slide.attr('data-swiper-slide-index');
							if (slide.hasClass(s.params.slideDuplicateClass)) {
								var originalSlide = s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ')');
								s.lazy.loadImageInSlide(originalSlide.index(), false);
							}
							else {
								var duplicatedSlide = s.wrapper.children('.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
								s.lazy.loadImageInSlide(duplicatedSlide.index(), false);
							}
						}
						s.emit('onLazyImageReady', s, slide[0], _img[0]);
					});
					
					s.emit('onLazyImageLoad', s, slide[0], _img[0]);
				});
				
			},
			load: function () {
				var i;
				if (s.params.watchSlidesVisibility) {
					s.wrapper.children('.' + s.params.slideVisibleClass).each(function () {
						s.lazy.loadImageInSlide($(this).index());
					});
				}
				else {
					if (s.params.slidesPerView > 1) {
						for (i = s.activeIndex; i < s.activeIndex + s.params.slidesPerView ; i++) {
							if (s.slides[i]) s.lazy.loadImageInSlide(i);
						}
					}
					else {
						s.lazy.loadImageInSlide(s.activeIndex);
					}
				}
				if (s.params.lazyLoadingInPrevNext) {
					if (s.params.slidesPerView > 1) {
						// Next Slides
						for (i = s.activeIndex + s.params.slidesPerView; i < s.activeIndex + s.params.slidesPerView + s.params.slidesPerView; i++) {
							if (s.slides[i]) s.lazy.loadImageInSlide(i);
						}
						// Prev Slides
						for (i = s.activeIndex - s.params.slidesPerView; i < s.activeIndex ; i++) {
							if (s.slides[i]) s.lazy.loadImageInSlide(i);
						}
					}
					else {
						var nextSlide = s.wrapper.children('.' + s.params.slideNextClass);
						if (nextSlide.length > 0) s.lazy.loadImageInSlide(nextSlide.index());
						
						var prevSlide = s.wrapper.children('.' + s.params.slidePrevClass);
						if (prevSlide.length > 0) s.lazy.loadImageInSlide(prevSlide.index());
					}
				}
			},
			onTransitionStart: function () {
				if (s.params.lazyLoading) {
					if (s.params.lazyLoadingOnTransitionStart || (!s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded)) {
						s.lazy.load();
					}
				}
			},
			onTransitionEnd: function () {
				if (s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart) {
					s.lazy.load();
				}
			}
		};
		
		
		/*=========================
		 Scrollbar
		 ===========================*/
		s.scrollbar = {
			isTouched: false,
			setDragPosition: function (e) {
				var sb = s.scrollbar;
				var x = 0, y = 0;
				var translate;
				var pointerPosition = isH() ?
					((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX) :
					((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY) ;
				var position = (pointerPosition) - sb.track.offset()[isH() ? 'left' : 'top'] - sb.dragSize / 2;
				var positionMin = -s.minTranslate() * sb.moveDivider;
				var positionMax = -s.maxTranslate() * sb.moveDivider;
				if (position < positionMin) {
					position = positionMin;
				}
				else if (position > positionMax) {
					position = positionMax;
				}
				position = -position / sb.moveDivider;
				s.updateProgress(position);
				s.setWrapperTranslate(position, true);
			},
			dragStart: function (e) {
				var sb = s.scrollbar;
				sb.isTouched = true;
				e.preventDefault();
				e.stopPropagation();
				
				sb.setDragPosition(e);
				clearTimeout(sb.dragTimeout);
				
				sb.track.transition(0);
				if (s.params.scrollbarHide) {
					sb.track.css('opacity', 1);
				}
				s.wrapper.transition(100);
				sb.drag.transition(100);
				s.emit('onScrollbarDragStart', s);
			},
			dragMove: function (e) {
				var sb = s.scrollbar;
				if (!sb.isTouched) return;
				if (e.preventDefault) e.preventDefault();
				else e.returnValue = false;
				sb.setDragPosition(e);
				s.wrapper.transition(0);
				sb.track.transition(0);
				sb.drag.transition(0);
				s.emit('onScrollbarDragMove', s);
			},
			dragEnd: function (e) {
				var sb = s.scrollbar;
				if (!sb.isTouched) return;
				sb.isTouched = false;
				if (s.params.scrollbarHide) {
					clearTimeout(sb.dragTimeout);
					sb.dragTimeout = setTimeout(function () {
						sb.track.css('opacity', 0);
						sb.track.transition(400);
					}, 1000);
					
				}
				s.emit('onScrollbarDragEnd', s);
				if (s.params.scrollbarSnapOnRelease) {
					s.slideReset();
				}
			},
			enableDraggable: function () {
				var sb = s.scrollbar;
				var target = s.support.touch ? sb.track : document;
				$(sb.track).on(s.touchEvents.start, sb.dragStart);
				$(target).on(s.touchEvents.move, sb.dragMove);
				$(target).on(s.touchEvents.end, sb.dragEnd);
			},
			disableDraggable: function () {
				var sb = s.scrollbar;
				var target = s.support.touch ? sb.track : document;
				$(sb.track).off(s.touchEvents.start, sb.dragStart);
				$(target).off(s.touchEvents.move, sb.dragMove);
				$(target).off(s.touchEvents.end, sb.dragEnd);
			},
			set: function () {
				if (!s.params.scrollbar) return;
				var sb = s.scrollbar;
				sb.track = $(s.params.scrollbar);
				sb.drag = sb.track.find('.swiper-scrollbar-drag');
				if (sb.drag.length === 0) {
					sb.drag = $('<div class="swiper-scrollbar-drag"></div>');
					sb.track.append(sb.drag);
				}
				sb.drag[0].style.width = '';
				sb.drag[0].style.height = '';
				sb.trackSize = isH() ? sb.track[0].offsetWidth : sb.track[0].offsetHeight;
				
				sb.divider = s.size / s.virtualSize;
				sb.moveDivider = sb.divider * (sb.trackSize / s.size);
				sb.dragSize = sb.trackSize * sb.divider;
				
				if (isH()) {
					sb.drag[0].style.width = sb.dragSize + 'px';
				}
				else {
					sb.drag[0].style.height = sb.dragSize + 'px';
				}
				
				if (sb.divider >= 1) {
					sb.track[0].style.display = 'none';
				}
				else {
					sb.track[0].style.display = '';
				}
				if (s.params.scrollbarHide) {
					sb.track[0].style.opacity = 0;
				}
			},
			setTranslate: function () {
				if (!s.params.scrollbar) return;
				var diff;
				var sb = s.scrollbar;
				var translate = s.translate || 0;
				var newPos;
				
				var newSize = sb.dragSize;
				newPos = (sb.trackSize - sb.dragSize) * s.progress;
				if (s.rtl && isH()) {
					newPos = -newPos;
					if (newPos > 0) {
						newSize = sb.dragSize - newPos;
						newPos = 0;
					}
					else if (-newPos + sb.dragSize > sb.trackSize) {
						newSize = sb.trackSize + newPos;
					}
				}
				else {
					if (newPos < 0) {
						newSize = sb.dragSize + newPos;
						newPos = 0;
					}
					else if (newPos + sb.dragSize > sb.trackSize) {
						newSize = sb.trackSize - newPos;
					}
				}
				if (isH()) {
					if (s.support.transforms3d) {
						sb.drag.transform('translate3d(' + (newPos) + 'px, 0, 0)');
					}
					else {
						sb.drag.transform('translateX(' + (newPos) + 'px)');
					}
					sb.drag[0].style.width = newSize + 'px';
				}
				else {
					if (s.support.transforms3d) {
						sb.drag.transform('translate3d(0px, ' + (newPos) + 'px, 0)');
					}
					else {
						sb.drag.transform('translateY(' + (newPos) + 'px)');
					}
					sb.drag[0].style.height = newSize + 'px';
				}
				if (s.params.scrollbarHide) {
					clearTimeout(sb.timeout);
					sb.track[0].style.opacity = 1;
					sb.timeout = setTimeout(function () {
						sb.track[0].style.opacity = 0;
						sb.track.transition(400);
					}, 1000);
				}
			},
			setTransition: function (duration) {
				if (!s.params.scrollbar) return;
				s.scrollbar.drag.transition(duration);
			}
		};
		
		/*=========================
		 Controller
		 ===========================*/
		s.controller = {
			LinearSpline: function (x, y) {
				this.x = x;
				this.y = y;
				this.lastIndex = x.length - 1;
				// Given an x value (x2), return the expected y2 value:
				// (x1,y1) is the known point before given value,
				// (x3,y3) is the known point after given value.
				var i1, i3;
				var l = this.x.length;
				
				this.interpolate = function (x2) {
					if (!x2) return 0;
					
					// Get the indexes of x1 and x3 (the array indexes before and after given x2):
					i3 = binarySearch(this.x, x2);
					i1 = i3 - 1;
					
					// We have our indexes i1 & i3, so we can calculate already:
					// y2 := ((x2x1)  (y3y1))  (x3x1) + y1
					return ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1];
				};
				
				var binarySearch = (function() {
					var maxIndex, minIndex, guess;
					return function(array, val) {
						minIndex = -1;
						maxIndex = array.length;
						while (maxIndex - minIndex > 1)
							if (array[guess = maxIndex + minIndex >> 1] <= val) {
								minIndex = guess;
							} else {
								maxIndex = guess;
							}
						return maxIndex;
					};
				})();
			},
			//xxx: for now i will just save one spline function to to
			getInterpolateFunction: function(c){
				if(!s.controller.spline) s.controller.spline = s.params.loop ?
					new s.controller.LinearSpline(s.slidesGrid, c.slidesGrid) :
					new s.controller.LinearSpline(s.snapGrid, c.snapGrid);
			},
			setTranslate: function (translate, byController) {
				var controlled = s.params.control;
				var multiplier, controlledTranslate;
				function setControlledTranslate(c) {
					// this will create an Interpolate function based on the snapGrids
					// x is the Grid of the scrolled scroller and y will be the controlled scroller
					// it makes sense to create this only once and recall it for the interpolation
					// the function does a lot of value caching for performance
					translate = c.rtl && c.params.direction === 'horizontal' ? -s.translate : s.translate;
					if (s.params.controlBy === 'slide') {
						s.controller.getInterpolateFunction(c);
						// i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
						// but it did not work out
						controlledTranslate = -s.controller.spline.interpolate(-translate);
					}
					
					if(!controlledTranslate || s.params.controlBy === 'container'){
						multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate());
						controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate();
					}
					
					if (s.params.controlInverse) {
						controlledTranslate = c.maxTranslate() - controlledTranslate;
					}
					c.updateProgress(controlledTranslate);
					c.setWrapperTranslate(controlledTranslate, false, s);
					c.updateActiveIndex();
				}
				if (s.isArray(controlled)) {
					for (var i = 0; i < controlled.length; i++) {
						if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
							setControlledTranslate(controlled[i]);
						}
					}
				}
				else if (controlled instanceof Swiper && byController !== controlled) {
					
					setControlledTranslate(controlled);
				}
			},
			setTransition: function (duration, byController) {
				var controlled = s.params.control;
				var i;
				function setControlledTransition(c) {
					c.setWrapperTransition(duration, s);
					if (duration !== 0) {
						c.onTransitionStart();
						c.wrapper.transitionEnd(function(){
							if (!controlled) return;
							if (c.params.loop && s.params.controlBy === 'slide') {
								c.fixLoop();
							}
							c.onTransitionEnd();
							
						});
					}
				}
				if (s.isArray(controlled)) {
					for (i = 0; i < controlled.length; i++) {
						if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
							setControlledTransition(controlled[i]);
						}
					}
				}
				else if (controlled instanceof Swiper && byController !== controlled) {
					setControlledTransition(controlled);
				}
			}
		};
		
		/*=========================
		 Hash Navigation
		 ===========================*/
		s.hashnav = {
			init: function () {
				if (!s.params.hashnav) return;
				s.hashnav.initialized = true;
				var hash = document.location.hash.replace('#', '');
				if (!hash) return;
				var speed = 0;
				for (var i = 0, length = s.slides.length; i < length; i++) {
					var slide = s.slides.eq(i);
					var slideHash = slide.attr('data-hash');
					if (slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)) {
						var index = slide.index();
						s.slideTo(index, speed, s.params.runCallbacksOnInit, true);
					}
				}
			},
			setHash: function () {
				if (!s.hashnav.initialized || !s.params.hashnav) return;
				document.location.hash = s.slides.eq(s.activeIndex).attr('data-hash') || '';
			}
		};
		
		/*=========================
		 Keyboard Control
		 ===========================*/
		function handleKeyboard(e) {
			if (e.originalEvent) e = e.originalEvent; //jquery fix
			var kc = e.keyCode || e.charCode;
			// Directions locks
			if (!s.params.allowSwipeToNext && (isH() && kc === 39 || !isH() && kc === 40)) {
				return false;
			}
			if (!s.params.allowSwipeToPrev && (isH() && kc === 37 || !isH() && kc === 38)) {
				return false;
			}
			if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
				return;
			}
			if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
				return;
			}

			/* Amethyst content */
			if ($('#obsidian-overlay.oo-active').length) {
				// Skip if obsidian is active
				return;
			}
			/* /Amethyst content */

			if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {
				var inView = false;
				//Check that swiper should be inside of visible area of window
				if (s.container.parents('.swiper-slide').length > 0 && s.container.parents('.swiper-slide-active').length === 0) {
					return;
				}
				var windowScroll = {
					left: window.pageXOffset,
					top: window.pageYOffset
				};
				var windowWidth = window.innerWidth;
				var windowHeight = window.innerHeight;
				var swiperOffset = s.container.offset();
				if (s.rtl) swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft;
				var swiperCoord = [
					[swiperOffset.left, swiperOffset.top],
					[swiperOffset.left + s.width, swiperOffset.top],
					[swiperOffset.left, swiperOffset.top + s.height],
					[swiperOffset.left + s.width, swiperOffset.top + s.height]
				];
				for (var i = 0; i < swiperCoord.length; i++) {
					var point = swiperCoord[i];
					if (
						point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth &&
						point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight
					) {
						inView = true;
					}
					
				}
				if (!inView) return;
			}
			if (isH()) {
				if (kc === 37 || kc === 39) {
					if (e.preventDefault) e.preventDefault();
					else e.returnValue = false;
				}
				if ((kc === 39 && !s.rtl) || (kc === 37 && s.rtl)) s.slideNext();
				if ((kc === 37 && !s.rtl) || (kc === 39 && s.rtl)) s.slidePrev();
			}
			else {
				if (kc === 38 || kc === 40) {
					if (e.preventDefault) e.preventDefault();
					else e.returnValue = false;
				}
				if (kc === 40) s.slideNext();
				if (kc === 38) s.slidePrev();
			}
		}
		s.disableKeyboardControl = function () {
			$(document).off('keydown', handleKeyboard);
		};
		s.enableKeyboardControl = function () {
			$(document).on('keydown', handleKeyboard);
		};
		
		
		/*=========================
		 Mousewheel Control
		 ===========================*/
		s.mousewheel = {
			event: false,
			lastScrollTime: (new window.Date()).getTime()
		};
		if (s.params.mousewheelControl) {
			try {
				new window.WheelEvent('wheel');
				s.mousewheel.event = 'wheel';
			} catch (e) {}
			
			if (!s.mousewheel.event && document.onmousewheel !== undefined) {
				s.mousewheel.event = 'mousewheel';
			}
			if (!s.mousewheel.event) {
				s.mousewheel.event = 'DOMMouseScroll';
			}
		}
		function handleMousewheel(e) {
			if (e.originalEvent) e = e.originalEvent; //jquery fix
			var we = s.mousewheel.event;
			var delta = 0;
			//Opera & IE
			if (e.detail) delta = -e.detail;
			//WebKits
			else if (we === 'mousewheel') {
				if (s.params.mousewheelForceToAxis) {
					if (isH()) {
						if (Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY)) delta = e.wheelDeltaX;
						else return;
					}
					else {
						if (Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX)) delta = e.wheelDeltaY;
						else return;
					}
				}
				else {
					delta = e.wheelDelta;
				}
			}
			//Old FireFox
			else if (we === 'DOMMouseScroll') delta = -e.detail;
			//New FireFox
			else if (we === 'wheel') {
				if (s.params.mousewheelForceToAxis) {
					if (isH()) {
						if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) delta = -e.deltaX;
						else return;
					}
					else {
						if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) delta = -e.deltaY;
						else return;
					}
				}
				else {
					delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? - e.deltaX : - e.deltaY;
				}
			}
			if (delta === 0) return;
			
			if (s.params.mousewheelInvert) delta = -delta;
			
			if (!s.params.freeMode) {
				if ((new window.Date()).getTime() - s.mousewheel.lastScrollTime > 60) {
					if (delta < 0) {
						if ((!s.isEnd || s.params.loop) && !s.animating) s.slideNext();
						else if (s.params.mousewheelReleaseOnEdges) return true;
					}
					else {
						if ((!s.isBeginning || s.params.loop) && !s.animating) s.slidePrev();
						else if (s.params.mousewheelReleaseOnEdges) return true;
					}
				}
				s.mousewheel.lastScrollTime = (new window.Date()).getTime();
				
			}
			else {
				//Freemode or scrollContainer:
				var position = s.getWrapperTranslate() + delta * s.params.mousewheelSensitivity;
				var wasBeginning = s.isBeginning,
					wasEnd = s.isEnd;
				
				if (position >= s.minTranslate()) position = s.minTranslate();
				if (position <= s.maxTranslate()) position = s.maxTranslate();
				
				s.setWrapperTransition(0);
				s.setWrapperTranslate(position);
				s.updateProgress();
				s.updateActiveIndex();
				
				if (!wasBeginning && s.isBeginning || !wasEnd && s.isEnd) {
					s.updateClasses();
				}
				
				if (s.params.freeModeSticky) {
					clearTimeout(s.mousewheel.timeout);
					s.mousewheel.timeout = setTimeout(function () {
						s.slideReset();
					}, 300);
				}
				
				// Return page scroll on edge positions
				if (position === 0 || position === s.maxTranslate()) return;
			}
			if (s.params.autoplay) s.stopAutoplay();
			
			if (e.preventDefault) e.preventDefault();
			else e.returnValue = false;
			return false;
		}
		s.disableMousewheelControl = function () {
			if (!s.mousewheel.event) return false;
			s.container.off(s.mousewheel.event, handleMousewheel);
			return true;
		};
		
		s.enableMousewheelControl = function () {
			if (!s.mousewheel.event) return false;
			s.container.on(s.mousewheel.event, handleMousewheel);
			return true;
		};
		
		/*=========================
		 Parallax
		 ===========================*/
		function setParallaxTransform(el, progress) {
			el = $(el);
			var p, pX, pY;
			
			p = el.attr('data-swiper-parallax') || '0';
			pX = el.attr('data-swiper-parallax-x');
			pY = el.attr('data-swiper-parallax-y');
			if (pX || pY) {
				pX = pX || '0';
				pY = pY || '0';
			}
			else {
				if (isH()) {
					pX = p;
					pY = '0';
				}
				else {
					pY = p;
					pX = '0';
				}
			}
			if ((pX).indexOf('%') >= 0) {
				pX = parseInt(pX, 10) * progress + '%';
			}
			else {
				pX = pX * progress + 'px' ;
			}
			if ((pY).indexOf('%') >= 0) {
				pY = parseInt(pY, 10) * progress + '%';
			}
			else {
				pY = pY * progress + 'px' ;
			}
			el.transform('translate3d(' + pX + ', ' + pY + ',0px)');
		}
		s.parallax = {
			setTranslate: function () {
				s.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){
					setParallaxTransform(this, s.progress);
					
				});
				s.slides.each(function () {
					var slide = $(this);
					slide.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () {
						var progress = Math.min(Math.max(slide[0].progress, -1), 1);
						setParallaxTransform(this, progress);
					});
				});
			},
			setTransition: function (duration) {
				if (typeof duration === 'undefined') duration = s.params.speed;
				s.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){
					var el = $(this);
					var parallaxDuration = parseInt(el.attr('data-swiper-parallax-duration'), 10) || duration;
					if (duration === 0) parallaxDuration = 0;
					el.transition(parallaxDuration);
				});
			}
		};
		
		
		/*=========================
		 Plugins API. Collect all and init all plugins
		 ===========================*/
		s._plugins = [];
		for (var plugin in s.plugins) {
			var p = s.plugins[plugin](s, s.params[plugin]);
			if (p) s._plugins.push(p);
		}
		// Method to call all plugins event/method
		s.callPlugins = function (eventName) {
			for (var i = 0; i < s._plugins.length; i++) {
				if (eventName in s._plugins[i]) {
					s._plugins[i][eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
				}
			}
		};
		
		/*=========================
		 Events/Callbacks/Plugins Emitter
		 ===========================*/
		function normalizeEventName (eventName) {
			if (eventName.indexOf('on') !== 0) {
				if (eventName[0] !== eventName[0].toUpperCase()) {
					eventName = 'on' + eventName[0].toUpperCase() + eventName.substring(1);
				}
				else {
					eventName = 'on' + eventName;
				}
			}
			return eventName;
		}
		s.emitterEventListeners = {
			
		};
		s.emit = function (eventName) {
			// Trigger callbacks
			if (s.params[eventName]) {
				s.params[eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
			}
			var i;
			// Trigger events
			if (s.emitterEventListeners[eventName]) {
				for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
					s.emitterEventListeners[eventName][i](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
				}
			}
			// Trigger plugins
			if (s.callPlugins) s.callPlugins(eventName, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
		};
		s.on = function (eventName, handler) {
			eventName = normalizeEventName(eventName);
			if (!s.emitterEventListeners[eventName]) s.emitterEventListeners[eventName] = [];
			s.emitterEventListeners[eventName].push(handler);
			return s;
		};
		s.off = function (eventName, handler) {
			var i;
			eventName = normalizeEventName(eventName);
			if (typeof handler === 'undefined') {
				// Remove all handlers for such event
				s.emitterEventListeners[eventName] = [];
				return s;
			}
			if (!s.emitterEventListeners[eventName] || s.emitterEventListeners[eventName].length === 0) return;
			for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
				if(s.emitterEventListeners[eventName][i] === handler) s.emitterEventListeners[eventName].splice(i, 1);
			}
			return s;
		};
		s.once = function (eventName, handler) {
			eventName = normalizeEventName(eventName);
			var _handler = function () {
				handler(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
				s.off(eventName, _handler);
			};
			s.on(eventName, _handler);
			return s;
		};
		
		// Accessibility tools
		s.a11y = {
			makeFocusable: function ($el) {
				$el.attr('tabIndex', '0');
				return $el;
			},
			addRole: function ($el, role) {
				$el.attr('role', role);
				return $el;
			},
			
			addLabel: function ($el, label) {
				$el.attr('aria-label', label);
				return $el;
			},
			
			disable: function ($el) {
				$el.attr('aria-disabled', true);
				return $el;
			},
			
			enable: function ($el) {
				$el.attr('aria-disabled', false);
				return $el;
			},
			
			onEnterKey: function (event) {
				if (event.keyCode !== 13) return;
				if ($(event.target).is(s.params.nextButton)) {
					s.onClickNext(event);
					if (s.isEnd) {
						s.a11y.notify(s.params.lastSlideMessage);
					}
					else {
						s.a11y.notify(s.params.nextSlideMessage);
					}
				}
				else if ($(event.target).is(s.params.prevButton)) {
					s.onClickPrev(event);
					if (s.isBeginning) {
						s.a11y.notify(s.params.firstSlideMessage);
					}
					else {
						s.a11y.notify(s.params.prevSlideMessage);
					}
				}
				if ($(event.target).is('.' + s.params.bulletClass)) {
					$(event.target)[0].click();
				}
			},
			
			liveRegion: $('<span class="swiper-notification" aria-live="assertive" aria-atomic="true"></span>'),
			
			notify: function (message) {
				var notification = s.a11y.liveRegion;
				if (notification.length === 0) return;
				notification.html('');
				notification.html(message);
			},
			init: function () {
				// Setup accessibility
				if (s.params.nextButton) {
					var nextButton = $(s.params.nextButton);
					s.a11y.makeFocusable(nextButton);
					s.a11y.addRole(nextButton, 'button');
					s.a11y.addLabel(nextButton, s.params.nextSlideMessage);
				}
				if (s.params.prevButton) {
					var prevButton = $(s.params.prevButton);
					s.a11y.makeFocusable(prevButton);
					s.a11y.addRole(prevButton, 'button');
					s.a11y.addLabel(prevButton, s.params.prevSlideMessage);
				}
				
				$(s.container).append(s.a11y.liveRegion);
			},
			initPagination: function () {
				if (s.params.pagination && s.params.paginationClickable && s.bullets && s.bullets.length) {
					s.bullets.each(function () {
						var bullet = $(this);
						s.a11y.makeFocusable(bullet);
						s.a11y.addRole(bullet, 'button');
						s.a11y.addLabel(bullet, s.params.paginationBulletMessage.replace(/{{index}}/, bullet.index() + 1));
					});
				}
			},
			destroy: function () {
				if (s.a11y.liveRegion && s.a11y.liveRegion.length > 0) s.a11y.liveRegion.remove();
			}
		};
		
		
		/*=========================
		 Init/Destroy
		 ===========================*/
		s.init = function () {
			if (s.params.loop) s.createLoop();
			s.updateContainerSize();
			s.updateSlidesSize();
			s.updatePagination();
			if (s.params.scrollbar && s.scrollbar) {
				s.scrollbar.set();
				if (s.params.scrollbarDraggable) {
					s.scrollbar.enableDraggable();
				}
			}
			if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
				if (!s.params.loop) s.updateProgress();
				s.effects[s.params.effect].setTranslate();
			}
			if (s.params.loop) {
				s.slideTo(s.params.initialSlide + s.loopedSlides, 0, s.params.runCallbacksOnInit);
			}
			else {
				s.slideTo(s.params.initialSlide, 0, s.params.runCallbacksOnInit);
				if (s.params.initialSlide === 0) {
					if (s.parallax && s.params.parallax) s.parallax.setTranslate();
					if (s.lazy && s.params.lazyLoading) {
						s.lazy.load();
						s.lazy.initialImageLoaded = true;
					}
				}
			}
			s.attachEvents();
			if (s.params.observer && s.support.observer) {
				s.initObservers();
			}
			if (s.params.preloadImages && !s.params.lazyLoading) {
				s.preloadImages();
			}
			if (s.params.autoplay) {
				s.startAutoplay();
			}
			if (s.params.keyboardControl) {
				if (s.enableKeyboardControl) s.enableKeyboardControl();
			}
			if (s.params.mousewheelControl) {
				if (s.enableMousewheelControl) s.enableMousewheelControl();
			}
			if (s.params.hashnav) {
				if (s.hashnav) s.hashnav.init();
			}
			if (s.params.a11y && s.a11y) s.a11y.init();
			s.emit('onInit', s);
		};
		
		// Cleanup dynamic styles
		s.cleanupStyles = function () {
			// Container
			s.container.removeClass(s.classNames.join(' ')).removeAttr('style');
			
			// Wrapper
			s.wrapper.removeAttr('style');
			
			// Slides
			if (s.slides && s.slides.length) {
				s.slides
					.removeClass([
						s.params.slideVisibleClass,
						s.params.slideActiveClass,
						s.params.slideNextClass,
						s.params.slidePrevClass
					].join(' '))
					.removeAttr('style')
					.removeAttr('data-swiper-column')
					.removeAttr('data-swiper-row');
			}
			
			// Pagination/Bullets
			if (s.paginationContainer && s.paginationContainer.length) {
				s.paginationContainer.removeClass(s.params.paginationHiddenClass);
			}
			if (s.bullets && s.bullets.length) {
				s.bullets.removeClass(s.params.bulletActiveClass);
			}
			
			// Buttons
			if (s.params.prevButton) $(s.params.prevButton).removeClass(s.params.buttonDisabledClass);
			if (s.params.nextButton) $(s.params.nextButton).removeClass(s.params.buttonDisabledClass);
			
			// Scrollbar
			if (s.params.scrollbar && s.scrollbar) {
				if (s.scrollbar.track && s.scrollbar.track.length) s.scrollbar.track.removeAttr('style');
				if (s.scrollbar.drag && s.scrollbar.drag.length) s.scrollbar.drag.removeAttr('style');
			}
		};
		
		// Destroy
		s.destroy = function (deleteInstance, cleanupStyles) {
			// Detach evebts
			s.detachEvents();
			// Stop autoplay
			s.stopAutoplay();
			// Disable draggable
			if (s.params.scrollbar && s.scrollbar) {
				if (s.params.scrollbarDraggable) {
					s.scrollbar.disableDraggable();
				}
			}
			// Destroy loop
			if (s.params.loop) {
				s.destroyLoop();
			}
			// Cleanup styles
			if (cleanupStyles) {
				s.cleanupStyles();
			}
			// Disconnect observer
			s.disconnectObservers();
			// Disable keyboard/mousewheel
			if (s.params.keyboardControl) {
				if (s.disableKeyboardControl) s.disableKeyboardControl();
			}
			if (s.params.mousewheelControl) {
				if (s.disableMousewheelControl) s.disableMousewheelControl();
			}
			// Disable a11y
			if (s.params.a11y && s.a11y) s.a11y.destroy();
			// Destroy callback
			s.emit('onDestroy');
			// Delete instance
			if (deleteInstance !== false) s = null;
		};
		
		s.init();
		
		
		
		// Return swiper instance
		return s;
	};
	
	
	/*==================================================
	 Prototype
	 ====================================================*/
	Swiper.prototype = {
		isSafari: (function () {
			var ua = navigator.userAgent.toLowerCase();
			return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
		})(),
		isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),
		isArray: function (arr) {
			return Object.prototype.toString.apply(arr) === '[object Array]';
		},
		/*==================================================
		 Browser
		 ====================================================*/
		browser: {
			ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
			ieTouch: (window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1) || (window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1)
		},
		/*==================================================
		 Devices
		 ====================================================*/
		device: (function () {
			var ua = navigator.userAgent;
			var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
			var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
			var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
			var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
			return {
				ios: ipad || iphone || ipod,
				android: android
			};
		})(),
		/*==================================================
		 Feature Detection
		 ====================================================*/
		support: {
			touch : (window.Modernizr && Modernizr.touch === true) || (function () {
				return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
			})(),
			
			transforms3d : (window.Modernizr && Modernizr.csstransforms3d === true) || (function () {
				var div = document.createElement('div').style;
				return ('webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div);
			})(),
			
			flexbox: (function () {
				var div = document.createElement('div').style;
				var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
				for (var i = 0; i < styles.length; i++) {
					if (styles[i] in div) return true;
				}
			})(),
			
			observer: (function () {
				return ('MutationObserver' in window || 'WebkitMutationObserver' in window);
			})()
		},
		/*==================================================
		 Plugins
		 ====================================================*/
		plugins: {}
	};
	
	
	/*===========================
	 Get Dom libraries
	 ===========================*/
	var swiperDomPlugins = ['jQuery', 'Zepto', 'Dom7'];
	for (var i = 0; i < swiperDomPlugins.length; i++) {
		if (window[swiperDomPlugins[i]]) {
			addLibraryPlugin(window[swiperDomPlugins[i]]);
		}
	}
	// Required DOM Plugins
	var domLib;
	if (typeof Dom7 === 'undefined') {
		domLib = window.Dom7 || window.Zepto || window.jQuery;
	}
	else {
		domLib = Dom7;
	}
	
	/*===========================
	 Add .swiper plugin from Dom libraries
	 ===========================*/
	function addLibraryPlugin(lib) {
		lib.fn.swiper = function (params) {
			var firstInstance;
			lib(this).each(function () {
				var s = new Swiper(this, params);
				if (!firstInstance) firstInstance = s;
			});
			return firstInstance;
		};
	}
	
	if (domLib) {
		if (!('transitionEnd' in domLib.fn)) {
			domLib.fn.transitionEnd = function (callback) {
				var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
					i, j, dom = this;
				function fireCallBack(e) {
					/*jshint validthis:true */
					if (e.target !== this) return;
					callback.call(this, e);
					for (i = 0; i < events.length; i++) {
						dom.off(events[i], fireCallBack);
					}
				}
				if (callback) {
					for (i = 0; i < events.length; i++) {
						dom.on(events[i], fireCallBack);
					}
				}
				return this;
			};
		}
		if (!('transform' in domLib.fn)) {
			domLib.fn.transform = function (transform) {
				for (var i = 0; i < this.length; i++) {
					var elStyle = this[i].style;
					elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
				}
				return this;
			};
		}
		if (!('transition' in domLib.fn)) {
			domLib.fn.transition = function (duration) {
				if (typeof duration !== 'string') {
					duration = duration + 'ms';
				}
				for (var i = 0; i < this.length; i++) {
					var elStyle = this[i].style;
					elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
				}
				return this;
			};
		}
	}
	
	window.Swiper = Swiper;
})();
/*===========================
 Swiper AMD Export
 ===========================*/
if (typeof(module) !== 'undefined')
{
	module.exports = window.Swiper;
}
else if (typeof define === 'function' && define.amd) {
	define([], function () {
		'use strict';
		return window.Swiper;
	});
}
// require "shards/obsidian/_obsidian.js"
/**
 * jquery-simple-datetimepicker (jquery.simple-dtpicker.js)
 * v1.13.0
 * (c) Masanori Ohgita.
 * https://github.com/mugifly/jquery-simple-datetimepicker
 **/

(function($) {
	var lang = {
		en: {
			days: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
			months: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
			sep: '-',
			format: 'YYYY-MM-DD hh:mm',
			prevMonth: 'Previous month',
			nextMonth: 'Next month',
			today: 'Today'
		},
		ru: {
			days: ['', '', '', '', '', '', ''],
			months: [ "", "", "", "", "", "", "", "", "", "", "", "" ],
			format: 'DD/MM/YYYY hh:mm'
		}
		//
	};
	/* ----- */

	/**
	 PickerHandler Object
	 **/
	var PickerHandler = function($picker, $input){
		this.$pickerObject = $picker;
		this.$inputObject = $input;
	};

	/* Get a picker */
	PickerHandler.prototype.getPicker = function(){
		return this.$pickerObject;
	};

	/* Get a input-field */
	PickerHandler.prototype.getInput = function(){
		return this.$inputObject;
	};

	/* Get the display state of a picker */
	PickerHandler.prototype.isShow = function(){
		var is_show = true;
		if (this.$pickerObject.css('display') == 'none') {
			is_show = false;
		}
		return is_show;
	};

	/* Show a picker */
	PickerHandler.prototype.show = function(){
		var $picker = this.$pickerObject;
		var $input = this.$inputObject;

		$picker.show();


		// Amethyst
		// Get options
		var opt = $picker.data('opt');
		// Add inverted/normal class
		if ($input.hasClass(opt.invertedClass) || (opt.invertedParents && $input.closest('.' + opt.invertedClass).length)) {
			// Element have 'inverted' class, or have parents with this class
			$picker.removeClass('datepicker--normal').addClass('datepicker--inverted');
		} else {
			// Normal class
			$picker.removeClass('datepicker--inverted').addClass('datepicker--normal');
		}
		var this2 = this;
		setTimeout(function() {
			// Clear cache
			$picker.addClass('datepicker_active');
			this2._relocate();
		}, 10);
		// eof Amethyst

		ActivePickerId = $input.data('pickerId');

		// Moved relocate into setTimeout
		//this._relocate();
	};

	/* Hide a picker */
	PickerHandler.prototype.hide = function(){
		var $picker = this.$pickerObject;
		var $input = this.$inputObject;
		setTimeout(function() {
			$picker.hide();
		}, 300);

		$picker.removeClass('datepicker_active');

	};

	/* Get a selected date from a picker */
	PickerHandler.prototype.getDate = function(){
		var $picker = this.$pickerObject;
		var $input = this.$inputObject;
		return getPickedDate($picker);
	};

	/* Set a specific date to a picker */
	PickerHandler.prototype.setDate = function(date){
		var $picker = this.$pickerObject;
		var $input = this.$inputObject;
		if (!isObj('Date', date)) {
			date = new Date(date);
		}

		draw_date($picker, {
			"isAnim": true,
			"isOutputToInputObject": true
		}, date);
	};

	/* Set a specific min date to a picker and redraw */
	PickerHandler.prototype.setMinDate = function(date){
		var $picker = this.$pickerObject;
		var $input = this.$inputObject;
		if (!isObj('Date', date)) {
			date = new Date(date);
		}
		$picker.data("minDate", date);
		if ($input.val()) {
			datepicked = new Date(getPickedDate($picker));
			draw_date($picker, {
				"isAnim": true,
				"isOutputToInputObject": true
			}, ((datepicked > date) ? datepicked : date));
		} else {
			draw_date($picker, {
				"isAnim": true,
				"isOutputToInputObject": false
			}, date);
		}
	};

	/* Set a specific max date to a picker and redraw */
	PickerHandler.prototype.setMaxDate = function(date){
		var $picker = this.$pickerObject;
		var $input = this.$inputObject;
		if (!isObj('Date', date)) {
			date = new Date(date);
		}
		$picker.data("maxDate", date);
		if ($input.val()) {
			datepicked = new Date(getPickedDate($picker));
			draw_date($picker, {
				"isAnim": true,
				"isOutputToInputObject": true
			}, ((datepicked < date) ? datepicked : date));
		} else {
			draw_date($picker, {
				"isAnim": true,
				"isOutputToInputObject": false
			}, date);
		}
	};

	/* Destroy a picker */
	PickerHandler.prototype.destroy = function(){
		var $picker = this.$pickerObject;
		var picker_id = $picker.data('pickerId');
		PickerObjects[picker_id] = null;
		$picker.remove();
	};

	/* Relocate a picker to position of the appended input-field. */
	PickerHandler.prototype._relocate = function(){
		var $picker = this.$pickerObject;
		var $input = this.$inputObject;

		if ($picker.hasClass('datepicker_active') && $input != null && $picker.data('isInline') === false) { // Float mode
			// Move position of a picker - vertical
			var input_outer_height = $input.outerHeight({'margin': true});
			if (!isObj('Number', input_outer_height)) {
				input_outer_height = $input.outerHeight();
			}
			var picker_outer_height = $picker.outerHeight({'margin': true});
			if (!isObj('Number', picker_outer_height)) {
				picker_outer_height = $picker.outerHeight();
			}

			// Set width to assure date and time are side by side
			/*if($(".datepicker_calendar", $picker).width() !== 0 && $(".datepicker_timelist", $picker).width() !== 0){
				$picker.parent().width($(".datepicker_calendar", $picker).width() + $(".datepicker_timelist", $picker).width() + 6);
			}*/
			if(parseInt($(window).height()) <= ($input.offset().top - $(document).scrollTop() + input_outer_height + picker_outer_height) ){
				// Display to top of an input-field
				$picker.parent().css('top', ($input.offset().top - picker_outer_height) + 'px');
				// Amethyst //
				$picker.addClass('dropdown-top').removeClass('dropdown-bottom');
				// eof Amethyst //
			} else {
				// Display to bottom of an input-field
				$picker.parent().css('top', ($input.offset().top + input_outer_height) + 'px');
				// Amethyst //
				$picker.removeClass('dropdown-top').addClass('dropdown-bottom');
				// eof Amethyst //
			}
			/*
			// Move position of a picker - horizontal
			if($picker.parent().width() + $input.offset().left > $(window).width()) {
				// Display left side stick to window
				$picker.parent().css('left', (($(window).width() - $picker.parent().width()) / 2) + 'px');
			} else {
				// Display left side stick to input
				$picker.parent().css('left', $input.offset().left + 'px');
			}
			*/
			/* Amethyst content */
			var pickWidth = $picker.parent().outerWidth();
			var inpLeft = $input.offset().left;
			var inpWidth = $input.outerWidth();
			var WW = $(window).width();
			if (pickWidth < 100 || (pickWidth + inpLeft > WW && inpLeft + inpWidth - pickWidth < 0)) {
				// Time only or not enough space for side align, align center
				$picker.parent().css('left', (inpLeft + (inpWidth / 2) - (pickWidth / 2)) + 'px');
				$picker.addClass('datepicker--align-center');
				$picker.removeClass('datepicker--align-left datepicker--align-right');
			} else if(pickWidth + inpLeft < WW) {
				// Display left side stick to input
				$picker.parent().css('left', (inpLeft) + 'px');
				$picker.addClass('datepicker--align-left');
				$picker.removeClass('datepicker--align-center datepicker--align-right');
			} else {
				// Display right side stick to input
				$picker.parent().css('left', (inpLeft + inpWidth - pickWidth) + 'px');
				$picker.addClass('datepicker--align-right');
				$picker.removeClass('datepicker--align-center datepicker--align-left');
			}
			// Display on most top of the z-index
			$picker.parent().css('z-index', 100000);
		}
	};

	/* ----- */

	var PickerObjects = [];
	var InputObjects = [];
	var ActivePickerId = -1;

	var getParentPickerObject = function(obj) {
		return $(obj).closest('.datepicker');
	};

	var getPickersInputObject = function($obj) {
		var $picker = getParentPickerObject($obj);
		if ($picker.data("inputObjectId") != null) {
			return $(InputObjects[$picker.data("inputObjectId")]);
		}
		return null;
	};

	var setToNow = function($obj) {
		var $picker = getParentPickerObject($obj);
		var date = new Date();
		draw($picker, {
			"isAnim": true,
			"isOutputToInputObject": true
		}, date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes());
	};

	var beforeMonth = function($obj) {

		var $picker = getParentPickerObject($obj);

		if ($picker.data('stateAllowBeforeMonth') === false) { // Not allowed
			return;
		}

		var date = getShownDate($picker);
		var targetMonth_lastDay = new Date(date.getFullYear(), date.getMonth(), 0).getDate();
		if (targetMonth_lastDay < date.getDate()) {
			date.setDate(targetMonth_lastDay);
		}
		draw($picker, {
			"isAnim": true,
			"isOutputToInputObject": false,
			"keepPickedDate": true
		}, date.getFullYear(), date.getMonth() - 1, date.getDate(), date.getHours(), date.getMinutes());

		var todayDate = new Date();
		var isCurrentYear = todayDate.getFullYear() == date.getFullYear();
		var isCurrentMonth = isCurrentYear && todayDate.getMonth() == date.getMonth();

		if (!isCurrentMonth || !$picker.data("futureOnly")) {
			if (targetMonth_lastDay < date.getDate()) {
				date.setDate(targetMonth_lastDay);
			}
			var newdate = new Date(date.getFullYear(), date.getMonth() - 1, date.getDate(), date.getHours(), date.getMinutes());
			if ($picker.data("minDate") && newdate < $picker.data("minDate"))
				newdate = $picker.data("minDate");
			draw($picker, {
				"isAnim": true,
				"isOutputToInputObject": false,
				"keepPickedDate": true
			}, newdate.getFullYear(), newdate.getMonth(), newdate.getDate(), newdate.getHours(), newdate.getMinutes());
		}

		// Manual relocate
		var $input = getPickersInputObject($obj);
		var handler = new PickerHandler($picker, $input);
		handler._relocate();
	};

	var nextMonth = function($obj) {
		var $picker = getParentPickerObject($obj);
		var date = getShownDate($picker);
		var targetMonth_lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
		if (targetMonth_lastDay < date.getDate()) {
			date.setDate(targetMonth_lastDay);
		}
		draw($picker, {
			"isAnim": true,
			"isOutputToInputObject": false,
			"keepPickedDate": true
		}, date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes());

		// Check a last date of a next month
		if (getLastDate(date.getFullYear(), date.getMonth() + 1) < date.getDate()) {
			date.setDate(getLastDate(date.getFullYear(), date.getMonth() + 1));
		}
		var newdate = new Date(date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes());
		if ($picker.data("maxDate") && newdate > $picker.data("maxDate"))
			newdate = $picker.data("maxDate");
		draw($picker, {
			"isAnim": true,
			"isOutputToInputObject": false,
			"keepPickedDate": true
		}, newdate.getFullYear(), newdate.getMonth(), newdate.getDate(), newdate.getHours(), newdate.getMinutes());

		// Manual relocate
		var $input = getPickersInputObject($obj);
		var handler = new PickerHandler($picker, $input);
		handler._relocate();
	};

	/**
	 Check a last date of a specified year and month
	 **/
	var getLastDate = function(year, month) {
		var date = new Date(year, month + 1, 0);
		return date.getDate();
	};

	var getDateFormat = function (format, locale, is_date_only, is_time_only) {
		if (format == "default") {
			// Default format
			format = translate(locale,'format');
			if (is_date_only) {
				// Convert the format to date-only (ex: YYYY/MM/DD)
				format = format.substring(0, format.search(' '));
			}
			else if (is_time_only) {
				format = format.substring(format.search(' ') + 1);
			}
		}
		return format; // Return date-format
	};

	var normalizeYear = function (year) {
		if (year < 99) { // change year for 4 digits
			var date = new Date();
			return parseInt(year) + parseInt(date.getFullYear().toString().substr(0, 2) + "00");
		}
		return year;
	};
	var parseDate = function (str, opt_date_format) {

		var re, m, date;
		if(opt_date_format != null){
			// Parse date & time with date-format

			// Match a string with date format
			var df = opt_date_format.replace(/(-|\/)/g, '[-\/]')
				.replace(/YYYY/gi, '(\\d{2,4})')
				.replace(/(YY|MM|DD|HH|hh|mm)/g, '(\\d{1,2})')
				.replace(/(M|D|H|h|m)/g, '(\\d{1,2})')
				.replace(/(tt|TT)/g, '([aApP][mM])');
			re = new RegExp(df);
			m = re.exec(str);
			if( m != null){

				// Generate the formats array (convert-table)
				var formats = [];
				var format_buf = '';
				var format_before_c = '';
				var df_ = opt_date_format;
				while (df_ != null && 0 < df_.length) {
					var format_c = df_.substring(0, 1); df_ = df_.substring(1, df_.length);
					if (format_before_c != format_c) {
						if(/(YYYY|YY|MM|DD|mm|dd|M|D|HH|H|hh|h|m|tt|TT)/.test(format_buf)){
							formats.push( format_buf );
							format_buf = '';
						} else {
							format_buf = '';
						}
					}
					format_buf += format_c;
					format_before_c = format_c;
				}
				if (format_buf !== '' && /(YYYY|YY|MM|DD|mm|dd|M|D|HH|H|hh|h|m|tt|TT)/.test(format_buf)){
					formats.push( format_buf );
				}

				// Convert a string (with convert-table) to a date object
				var year, month, day, hour, min;
				var is_successful = false;
				var pm = false;
				var H = false;
				for(var i = 0; i < formats.length; i++){
					if(m.length < i){
						break;
					}

					var f = formats[i];
					var d = m[i+1]; // Matched part of date
					if(f == 'YYYY'){
						year = normalizeYear(d);
						is_successful = true;
					} else if(f == 'YY'){
						year = parseInt(d) + 2000;
						is_successful = true;
					} else if(f == 'MM' || f == 'M'){
						month = parseInt(d) - 1;
						is_successful = true;
					} else if(f == 'DD' || f == 'D'){
						day = d;
						is_successful = true;
					} else if(f == 'hh' || f == 'h'){
						hour = d;
						is_successful = true;
					} else if(f == 'HH' || f == 'H'){
						hour = d;
						H = true;
						is_successful = true;
					} else if(f == 'mm' || f == 'm'){
						min = d;
						is_successful = true;
					} else if(f == 'tt' || f == 'TT'){
						if(d == 'pm' || d == 'PM'){
							pm = true;
						}
						is_successful = true;
					}
				}
				if(H) {
					if(pm) {
						if(hour != 12) {
							hour = parseInt(hour) + 12;
						}
					} else if(hour == 12) {
						hour = 0;
					}
				}
				if (is_successful == true) {
					if (!year) {
						year = 2000;
					}
					if (!month) {
						month = 1;
					}
					if (!day) {
						day = 1;
					}
					if (!hour) {
						hour = 0;
					}
					if (!min) {
						min = 1;
					}
				}
				date = new Date(year, month, day, hour, min);

				if(is_successful === true && isNaN(date) === false && isNaN(date.getDate()) === false){ // Parse successful
					return date;
				}
			}
		}

		// Parse date & time with common format
		re = /^(\d{2,4})[-\/](\d{1,2})[-\/](\d{1,2}) (\d{1,2}):(\d{1,2})$/;
		m = re.exec(str);
		if (m !== null) {
			m[1] = normalizeYear(m[1]);
			date = new Date(m[1], m[2] - 1, m[3], m[4], m[5]);
		} else {
			// Parse for date-only
			re = /^(\d{2,4})[-\/](\d{1,2})[-\/](\d{1,2})$/;
			m = re.exec(str);
			if(m !== null) {
				m[1] = normalizeYear(m[1]);
				date = new Date(m[1], m[2] - 1, m[3]);
			}
		}

		if(isNaN(date) === false && isNaN(date.getDate()) === false){ // Parse successful
			return date;
		}
		return false;
	};
	var getFormattedDate = function(date, date_format) {
		if(date == null){
			date = new Date();
		}

		var y = date.getFullYear();
		var m = date.getMonth() + 1;
		var d = date.getDate();
		var hou = date.getHours();
		var min = date.getMinutes();

		date_format = date_format.replace(/YYYY/gi, y)
			.replace(/YY/g, y - 2000)/* century */
			.replace(/MM/g, zpadding(m))
			.replace(/M/g, m)
			.replace(/DD/g, zpadding(d))
			.replace(/D/g, d)
			.replace(/hh/g, zpadding(hou))
			.replace(/h/g, hou)
			.replace(/HH/g, (hou > 12? zpadding(hou - 12) : (hou < 1? 12 : zpadding(hou))))
			.replace(/H/g, (hou > 12? hou - 12 : (hou < 1? 12 : hou)))
			.replace(/mm/g, zpadding(min))
			.replace(/m/g, min)
			.replace(/tt/g, (hou >= 12? "pm" : "am"))
			.replace(/TT/g, (hou >= 12? "PM" : "AM"));
		return date_format;
	};

	var outputToInputObject = function($picker) {
		var $inp = getPickersInputObject($picker);
		if ($inp == null) {
			return;
		}
		var date = getPickedDate($picker);
		var locale = $picker.data("locale");
		var format = getDateFormat($picker.data("dateFormat"), locale, $picker.data('dateOnly'), $picker.data('timeOnly'));
		var old = $inp.val();
		$inp.val(getFormattedDate(date, format));
		if (old != $inp.val()) { // only trigger if it actually changed to avoid a nasty loop condition
			$inp.trigger("change");
		}
	};

	var getShownDate = function($obj) {
		var $picker = getParentPickerObject($obj);
		return $picker.data("shownDate");
	};

	var getPickedDate = function($obj) {
		var $picker = getParentPickerObject($obj);
		return $picker.data("pickedDate");
	};

	var zpadding = function(num) {
		num = ("0" + num).slice(-2);
		return num;
	};

	var draw_date = function($picker, option, date) {
		//console.log("draw_date - " + date.toString());
		draw($picker, option, date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes());
	};
	var translate = function(locale, s) {
		if (typeof lang[locale][s] !== "undefined"){
			return lang[locale][s];
		}
		return lang.en[s];
	};
	var draw = function($picker, option, year, month, day, hour, min) {

		var date = new Date();

		if (hour != null) {
			date = new Date(year, month, day, hour, min, 0);
		} else if (year != null) {
			date = new Date(year, month, day);
		} else {
			date = new Date();
		}

		/* Read options */
		var isTodayButton = $picker.data("todayButton");
		var isCloseButton = $picker.data("closeButton");
		var isScroll = option.isAnim; /* It same with isAnim */
		if($picker.data("timelistScroll") === false) {// If disabled by user option.
			isScroll = false;
		}

		var isAnim = option.isAnim;
		if($picker.data("animation") === false){ // If disabled by user option.
			isAnim = false;
		}

		var isFutureOnly = $picker.data("futureOnly");
		var minDate = $picker.data("minDate");
		var maxDate = $picker.data("maxDate");

		var isOutputToInputObject = option.isOutputToInputObject;
		var keepPickedDate = option.keepPickedDate;
		if (typeof keepPickedDate === "undefined") keepPickedDate = false;

		var minuteInterval = $picker.data("minuteInterval");
		var firstDayOfWeek = $picker.data("firstDayOfWeek");

		var allowWdays = $picker.data("allowWdays");
		if (allowWdays == null || isObj('Array', allowWdays) === false || allowWdays.length <= 0) {
			allowWdays = null;
		}

		var minTime = $picker.data("minTime");
		var maxTime = $picker.data("maxTime");

		/* Check a specified date */
		var todayDate = new Date();
		if (isFutureOnly) {
			if (date.getTime() < todayDate.getTime()) { // Already passed
				date.setTime(todayDate.getTime());
			}
		}
		if(allowWdays != null && allowWdays.length <= 6) {
			while (true) {
				if ($.inArray(date.getDay(), allowWdays) == -1) { // Unallowed wday
					// Slide a date
					date.setDate(date.getDate() + 1);
				} else {
					break;
				}
			}
		}

		/* Read locale option */
		var locale = $picker.data("locale");
		if (!lang.hasOwnProperty(locale)) {
			locale = 'en';
		}

		/* Calculate dates */
		var firstWday = new Date(date.getFullYear(), date.getMonth(), 1).getDay() - firstDayOfWeek;
		var lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
		var beforeMonthLastDay = new Date(date.getFullYear(), date.getMonth(), 0).getDate();
		var dateBeforeMonth = new Date(date.getFullYear(), date.getMonth(), 0);
		var dateNextMonth = new Date(date.getFullYear(), date.getMonth() + 2, 0);
		var isCurrentYear = todayDate.getFullYear() == date.getFullYear();
		var isCurrentMonth = isCurrentYear && todayDate.getMonth() == date.getMonth();
		var isCurrentDay = isCurrentMonth && todayDate.getDate() == date.getDate();
		var isNextYear = (todayDate.getFullYear() + 1 == date.getFullYear());
		var isNextMonth = (isCurrentYear && todayDate.getMonth() + 1 == date.getMonth()) ||
			(isNextYear && todayDate.getMonth() === 11 && date.getMonth() === 0);
		var isPastMonth = false;
		if (date.getFullYear() < todayDate.getFullYear() || (isCurrentYear && date.getMonth() < todayDate.getMonth())) {
			isPastMonth = true;
		}

		/* Collect each part */
		var $header = $picker.children('.datepicker_header');
		var $inner = $picker.children('.datepicker_inner_container');
		var $calendar = $picker.children('.datepicker_inner_container').children('.datepicker_calendar');
		var $table = $calendar.children('.datepicker_table');
		var $timelist;
		if ($picker.children('.datepicker_inner_container').children('.datepicker_timelist.scroll-content').length) {
			$timelist = $picker.children('.datepicker_inner_container').children('.datepicker_timelist.scroll-content');
		} else {
			$timelist = $picker.children('.datepicker_inner_container').children('.datepicker_timelist');
		}

		/* Grasp a point that will be changed */
		var changePoint = "";
		var oldDate = getPickedDate($picker);
		if(oldDate != null){
			if(oldDate.getMonth() != date.getMonth() || oldDate.getDate() != date.getDate()){
				changePoint = "calendar";
			} else if (oldDate.getHours() != date.getHours() || oldDate.getMinutes() != date.getMinutes()){
				if(date.getMinutes() === 0 || date.getMinutes() % minuteInterval === 0){
					changePoint = "timelist";
				}
			}
		}

		/* Save newly date to Picker data */
		if (keepPickedDate === false) {
			$($picker).data("pickedDate", date);
		}
		$($picker).data("shownDate", date);

		/* Fade-out animation */
		if (isAnim === true) {
			if(changePoint == "calendar"){
				$calendar.stop().queue([]);
				$calendar.fadeTo("fast", 0.8);
			}else if(changePoint == "timelist"){
				$timelist.stop().queue([]);
				$timelist.fadeTo("fast", 0.8);
			}
		}
		/* Remind timelist scroll state */
		var drawBefore_timeList_scrollTop = $timelist.scrollTop();

		/* New timelist  */
		var timelist_activeTimeCell_offsetTop = -1;

		/* Header ----- */
		$header.children().remove();

		var cDate =  new Date(date.getTime());
		cDate.setMinutes(59);
		cDate.setHours(23);
		cDate.setSeconds(59);
		cDate.setDate(0); // last day of previous month

		var $link_before_month = null;
		if ((!isFutureOnly || !isCurrentMonth) && ((minDate == null) || (minDate < cDate.getTime()))
		) {
			$link_before_month = $('<a>');
			$link_before_month.text('');
			$link_before_month.prop('alt', translate(locale,'prevMonth'));
			$link_before_month.prop('title', translate(locale,'prevMonth') );
			$link_before_month.prop('class', 'icon-prevmonth' );
			$link_before_month.click(function() {
				beforeMonth($picker);
			});
			$picker.data('stateAllowBeforeMonth', true);
		} else {
			$picker.data('stateAllowBeforeMonth', false);
		}

		cDate.setMinutes(0);
		cDate.setHours(0);
		cDate.setSeconds(0);
		cDate.setDate(1); // First day of next month
		cDate.setMonth(date.getMonth() + 1);

		var $now_month = $('<span>');
		$now_month.text(date.getFullYear() + " " + translate(locale, 'sep') + " " + translate(locale, 'months')[date.getMonth()]);

		var $link_next_month = null;
		if ((maxDate == null) || (maxDate > cDate.getTime())) {
			$link_next_month = $('<a>');
			$link_next_month.text('');
			$link_next_month.prop('alt', translate(locale,'nextMonth'));
			$link_next_month.prop('title', translate(locale,'nextMonth'));
			$link_next_month.prop('class', 'icon-nextmonth' );
			$link_next_month.click(function() {
				nextMonth($picker);
			});
		}

		if (isTodayButton) {
			var $link_today = $('<a><div/></a>');
			$link_today.addClass('icon-home');
			$link_today.prop('alt', translate(locale,'today'));
			$link_today.prop('title', translate(locale,'today'));
			$link_today.click(function() {
				setToNow($picker);
			});
			$header.append($link_today);
		}
		if (isCloseButton) {
			var $link_close = $('<a><div/></a>');
			$link_close.addClass('icon-close');
			$link_close.prop('alt', translate(locale,'close'));
			$link_close.prop('title', translate(locale,'close'));
			$link_close.click(function() {
				setTimeout(function() {
					$picker.hide();
				}, 300);

				$picker.removeClass('datepicker_active');
			});
			$header.append($link_close);
		}

		if ($link_before_month != null) {
			$header.append($link_before_month);
		}
		$header.append($now_month);
		if ($link_next_month != null) {
			$header.append($link_next_month);
		}

		/* Calendar > Table ----- */
		$table.children().remove();
		var $tr = $('<tr>');
		$table.append($tr);

		/* Output wday cells */
		var firstDayDiff = 7 + firstDayOfWeek;
		var daysOfWeek = translate(locale,'days');
		var $td;
		for (var i = 0; i < 7; i++) {
			$td = $('<th>');
			$td.text(daysOfWeek[((i + firstDayDiff) % 7)]);
			$tr.append($td);
		}

		/* Output day cells */
		var cellNum = Math.ceil((firstWday + lastDay) / 7) * 7;
		i = 0;
		if(firstWday < 0){
			i = -7;
		}
		var realDayObj =  new Date(date.getTime());
		realDayObj.setHours(0);
		realDayObj.setMinutes(0);
		realDayObj.setSeconds(0);
		var pickedDate = getPickedDate($picker);
		var shownDate = getShownDate($picker);
		for (var zz = 0; i < cellNum; i++) {
			var realDay = i + 1 - firstWday;

			var isPast = isPastMonth ||
				(isCurrentMonth && realDay < todayDate.getDate()) ||
				(isNextMonth && firstWday > i && (beforeMonthLastDay + realDay) < todayDate.getDate());

			if (i % 7 === 0) {
				$tr = $('<tr>');
				$table.append($tr);
			}

			$td = $('<td>');
			$td.data("day", realDay);

			$tr.append($td);

			if (firstWday > i) {/* Before months day */
				$td.text(beforeMonthLastDay + realDay);
				$td.addClass('day_another_month');
				$td.data("dateStr", dateBeforeMonth.getFullYear() + "/" + (dateBeforeMonth.getMonth() + 1) + "/" + (beforeMonthLastDay + realDay));
				realDayObj.setDate(beforeMonthLastDay + realDay);
				realDayObj.setMonth(dateBeforeMonth.getMonth() );
				realDayObj.setYear(dateBeforeMonth.getFullYear() );
			} else if (i < firstWday + lastDay) {/* Now months day */
				$td.text(realDay);
				$td.data("dateStr", (date.getFullYear()) + "/" + (date.getMonth() + 1) + "/" + realDay);
				realDayObj.setDate( realDay );
				realDayObj.setMonth( date.getMonth()  );
				realDayObj.setYear( date.getFullYear() );
			} else {/* Next months day */
				$td.text(realDay - lastDay);
				$td.addClass('day_another_month');
				$td.data("dateStr", dateNextMonth.getFullYear() + "/" + (dateNextMonth.getMonth() + 1) + "/" + (realDay - lastDay));
				realDayObj.setDate( realDay - lastDay );
				realDayObj.setMonth( dateNextMonth.getMonth() );
				realDayObj.setYear( dateNextMonth.getFullYear() );
			}

			/* Check a wday */
			var wday = ((i + firstDayDiff) % 7);
			if(allowWdays != null) {
				if ($.inArray(wday, allowWdays) == -1) {
					$td.addClass('day_in_unallowed');
					continue; // Skip
				}
			} else if (wday === 0) {/* Sunday */
				$td.addClass('wday_sun');
			} else if (wday == 6) {/* Saturday */
				$td.addClass('wday_sat');
			}

			/* Set a special mark class */
			if (shownDate.getFullYear() == pickedDate.getFullYear() && shownDate.getMonth() == pickedDate.getMonth() && realDay == pickedDate.getDate()) { /* selected day */
				$td.addClass('active');
			}

			if (isCurrentMonth && realDay == todayDate.getDate()) { /* today */
				$td.addClass('today');
			}

			var realDayObjMN =  new Date(realDayObj.getTime());
			realDayObjMN.setHours(23);
			realDayObjMN.setMinutes(59);
			realDayObjMN.setSeconds(59);

			if (
				// compare to 23:59:59 on the current day (if MIN is 1pm, then we still need to show this day
			((minDate != null) && (minDate > realDayObjMN.getTime())) || ((maxDate != null) && (maxDate < realDayObj.getTime())) // compare to 00:00:00
			) { // Out of range day
				$td.addClass('out_of_range');
			} else if (isFutureOnly && isPast) { // Past day
				$td.addClass('day_in_past');
			} else {
				/* Set event-handler to day cell */
				$td.click(function(ev) {
					ev.stopPropagation();

					$(this).addClass('active');

					var $picker = getParentPickerObject($(this));
					var targetDate = new Date($(this).data("dateStr"));
					var selectedDate = getPickedDate($picker);
					draw($picker, {
						"isAnim": false,
						"isOutputToInputObject": true
					}, targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate(), selectedDate.getHours(), selectedDate.getMinutes());

					// Generate the handler of a picker
					var $input = $(this);
					var handler = new PickerHandler($picker, $input);

					// Call a event-hanlder for onSelect
					var func = $picker.data('onSelect');
					if (func != null) {
						func(handler, targetDate);
					}

					if ($picker.data("dateOnly") === true && $picker.data("isInline") === false && $picker.data("closeOnSelected")){
						// Close a picker
						ActivePickerId = -1;
						setTimeout(function() {
							$picker.hide();
						}, 300);

						$picker.removeClass('datepicker_active');
					}
				});

			}

			/* ---- */
		}

		if ($picker.data('timeOnly') === true) {
			$picker.addClass('datepicker-timeonly');
			$calendar.css("display", "none");
			$now_month.css("display", "none");
			if ($link_next_month != null)
				$link_next_month.css("display", "none");
			if ($link_before_month != null)
				$link_before_month.css("display", "none");
		}

		if ($picker.data("dateOnly") === true) {
			/* dateOnly mode */
			$picker.addClass('datepicker-dateonly');
			$timelist.css("display", "none");
		} else {
			/* Timelist ----- */

			/* Set height to Timelist (Calendar innerHeight - Calendar padding) */
			//if ($calendar.find('.datepicker_table').innerHeight() > 0) {
			//	$timelist.css("height", $calendar.find('.datepicker_table').innerHeight() - 5 + 'px');
			//}

			if ($timelist.find('.scroll-content').length) {
				// Go deeper
				$timelist = $timelist.find('.scroll-content');
			}
			$timelist.children().remove();

			realDayObj =  new Date(date.getTime());

			/* Output time cells */
			var hour_ = minTime[0];
			var min_ = minTime[1];

			while( hour_*100+min_ < maxTime[0]*100+maxTime[1] ){

				var $o = $('<div>');
				var is_past_time = hour_ < todayDate.getHours() || (hour_ == todayDate.getHours() && min_ < todayDate.getMinutes());
				var is_past = isCurrentDay && is_past_time;

				$o.addClass('timelist_item');
				var oText = "";
				if($picker.data("amPmInTimeList")){
					oText = /*zpadding*/(hour_ > 12? hour_ - 12 : (hour_ < 1? 12 : hour_));
					oText += ":" + zpadding(min_);
					oText += (hour_ >= 12? "PM" : "AM");
				} else {
					oText = zpadding(hour_) + ":" + zpadding(min_);
				}
				$o.text(oText);
				$o.data("hour", hour_);
				$o.data("min", min_);

				$timelist.append($o);

				realDayObj.setHours(hour_);
				realDayObj.setMinutes(min_);

				if (
					((minDate != null) && (minDate > realDayObj.getTime())) || ((maxDate != null) && (maxDate < realDayObj.getTime()))
				) { // Out of range cell
					$o.addClass('out_of_range');
				} else if (isFutureOnly && is_past) { // Past cell
					$o.addClass('time_in_past');
				} else { // Normal cell
					/* Set event handler to time cell */
					$o.click(function(ev) {
						ev.stopPropagation();

						$(this).addClass('active');

						var $picker = getParentPickerObject($(this));
						var date = getPickedDate($picker);
						var hour = $(this).data("hour");
						var min = $(this).data("min");
						draw($picker, {
							"isAnim": false,
							"isOutputToInputObject": true
						}, date.getFullYear(), date.getMonth(), date.getDate(), hour, min);

						if ($picker.data("isInline") === false && $picker.data("closeOnSelected")){
							// Close a picker
							ActivePickerId = -1;
							setTimeout(function() {
								$picker.hide();
							}, 300);

							$picker.removeClass('datepicker_active');
						}
					});
				}

				if (hour_ == date.getHours() && min_ == date.getMinutes()) { /* selected time */
					$o.addClass('active');
					timelist_activeTimeCell_offsetTop = $o.offset().top;
				}

				min_ += minuteInterval;
				if (min_ >= 60){
					min_ = min_ - 60;
					hour_++;
				}

			}

			/* Scroll the timelist */
			if(isScroll === true){
				/* Scroll to new active time-cell position */
				$timelist.scrollTop(timelist_activeTimeCell_offsetTop - $timelist.offset().top);
			}else{
				/* Scroll to position that before redraw. */
				$timelist.scrollTop(drawBefore_timeList_scrollTop);
			}
		}

		/* Fade-in animation */
		if (isAnim === true) {
			if (changePoint == 'calendar' && $picker.data('timeOnly') === false) {
				$calendar.fadeTo('fast', 1.0);
			} else if (changePoint == 'timelist' && $picker.data('dateOnly') === false) {
				$timelist.fadeTo('fast', 1.0);
			}
		}

		/* Output to InputForm */
		if (isOutputToInputObject === true) {
			outputToInputObject($picker);
		}

		var $inp = getPickersInputObject($picker);
		var handler = new PickerHandler($picker, $inp);
		handler._relocate();
	};

	/* Check for object type */
	var isObj = function(type, obj) {
		/* http://qiita.com/Layzie/items/465e715dae14e2f601de */
		var clas = Object.prototype.toString.call(obj).slice(8, -1);
		return obj !== undefined && obj !== null && clas === type;
	};

	var init = function($obj, opt) {
		/* Container */
		var $picker = $('<div>');

		$picker.destroy = function() {
			window.alert('destroy!');
		};

		$picker.addClass('datepicker');
		$obj.append($picker);

		/* Set current date */
		if(!opt.current) {
			opt.current = new Date();
		} else {
			var format = getDateFormat(opt.dateFormat, opt.locale, opt.dateOnly, opt.timeOnly);
			var date = parseDate(opt.current, format);
			if (date) {
				opt.current = date;
			} else {
				opt.current = new Date();
			}
		}

		/* Set options data to container object  */
		if (opt.inputObjectId != null) $picker.data("inputObjectId", opt.inputObjectId);
		if (opt.timeOnly) opt.todayButton = false;
		$picker.data("timeOnly", opt.timeOnly);
		$picker.data("dateOnly", opt.dateOnly);
		$picker.data("pickerId", PickerObjects.length);
		$picker.data("dateFormat", opt.dateFormat);
		$picker.data("locale", opt.locale);
		$picker.data("firstDayOfWeek", opt.firstDayOfWeek);
		$picker.data("animation", opt.animation);
		$picker.data("closeOnSelected", opt.closeOnSelected);
		$picker.data("timelistScroll", opt.timelistScroll);
		$picker.data("calendarMouseScroll", opt.calendarMouseScroll);
		$picker.data("todayButton", opt.todayButton);
		$picker.data("closeButton", opt.closeButton);
		$picker.data('futureOnly', opt.futureOnly);
		$picker.data('onShow', opt.onShow);
		$picker.data('onHide', opt.onHide);
		$picker.data('onSelect', opt.onSelect);
		$picker.data('onInit', opt.onInit);
		$picker.data('allowWdays', opt.allowWdays);

		if(opt.amPmInTimeList === true){
			$picker.data('amPmInTimeList', true);
		} else {
			$picker.data('amPmInTimeList', false);
		}

		var minDate = Date.parse(opt.minDate);
		if (isNaN(minDate)) { // invalid date?
			$picker.data('minDate', null); // set to null
		} else {
			$picker.data('minDate', minDate);
		}

		var maxDate = Date.parse(opt.maxDate);
		if (isNaN(maxDate)) { // invalid date?
			$picker.data('maxDate', null);  // set to null
		} else {
			$picker.data('maxDate', maxDate);
		}
		$picker.data("state", 0);

		if( 5 <= opt.minuteInterval && opt.minuteInterval <= 30 ){
			$picker.data("minuteInterval", opt.minuteInterval);
		} else {
			$picker.data("minuteInterval", 30);
		}
		opt.minTime = opt.minTime.split(':');
		opt.maxTime = opt.maxTime.split(':');

		if(! ((opt.minTime[0] >= 0 ) && (opt.minTime[0] <24 ))){
			opt.minTime[0]="00";
		}
		if(! ((opt.maxTime[0] >= 0 ) && (opt.maxTime[0] <24 ))){
			opt.maxTime[0]="23";
		}
		if(! ((opt.minTime[1] >= 0 ) && (opt.minTime[1] <60 ))){
			opt.minTime[1]="00";
		}
		if(! ((opt.maxTime[1] >= 0 ) && (opt.maxTime[1] <24 ))){
			opt.maxTime[1]="59";
		}
		opt.minTime[0]=parseInt(opt.minTime[0], 10); // parse as decimal number
		opt.minTime[1]=parseInt(opt.minTime[1], 10);
		opt.maxTime[0]=parseInt(opt.maxTime[0], 10);
		opt.maxTime[1]=parseInt(opt.maxTime[1], 10);
		$picker.data('minTime', opt.minTime);
		$picker.data('maxTime', opt.maxTime);

		/* Header */
		var $header = $('<div>');
		$header.addClass('datepicker_header');
		$picker.append($header);
		/* InnerContainer*/
		var $inner = $('<div>');
		$inner.addClass('datepicker_inner_container');
		$picker.append($inner);
		/* Calendar */
		var $calendar = $('<div>');
		$calendar.addClass('datepicker_calendar');
		var $table = $('<table>');
		$table.addClass('datepicker_table');
		$calendar.append($table);
		$inner.append($calendar);
		/* Timelist */
		var $timelist = $('<div>');
		$timelist.addClass('datepicker_timelist');
		$inner.append($timelist);

		/* Set event-handler to calendar */
		if (opt.calendarMouseScroll) {
			if (window.sidebar) { // Mozilla Firefox
				$calendar.bind('DOMMouseScroll', function(e){ // Change a month with mouse wheel scroll for Fx
					var $picker = getParentPickerObject($(this));

					// up,left [delta < 0] down,right [delta > 0]
					var delta = e.originalEvent.detail;
					/*
					 // this code need to be commented - it's seems to be unnecessary
					 // normalization (/3) is not needed as we move one month back or forth
					 if(e.originalEvent.axis !== undefined && e.originalEvent.axis == e.originalEvent.HORIZONTAL_AXIS){
					 e.deltaX = delta;
					 e.deltaY = 0;
					 } else {
					 e.deltaX = 0;
					 e.deltaY = delta;
					 }
					 e.deltaX /= 3;
					 e.deltaY /= 3;
					 */
					if(delta > 0) {
						nextMonth($picker);
					} else {
						beforeMonth($picker);
					}
					return false;
				});
			} else { // Other browsers
				$calendar.bind('mousewheel', function(e){ // Change a month with mouse wheel scroll
					var $picker = getParentPickerObject($(this));
					// up [delta > 0] down [delta < 0]
					if(e.originalEvent.wheelDelta /120 > 0) {
						beforeMonth($picker);
					} else {
						nextMonth($picker);
					}
					return false;
				});
			}
		}

		PickerObjects.push($picker);

		draw_date($picker, {
			"isAnim": true,
			"isOutputToInputObject": opt.autodateOnStart
		}, opt.current);

		/* Amethyst content */
		// Add scrollbar
		if($picker.find('.datepicker_timelist').length && !$picker.find('.scroll-content').length) {
			// Initialize scrollbar
			$picker.find('.datepicker_timelist').removeClass('scroll-wrapper');
			$picker.find('.datepicker_timelist').scrollbar({ignoreMobile: false});
		}
		// Add options to picker object
		$picker.data('opt', opt);
		/* /Amethyst content */
	};

	var getDefaults = function() {
		return {
			"current": null,
			"dateFormat": "default",
			"locale": "ru",
			"animation": false,
			"minuteInterval": 30,
			"firstDayOfWeek": 1,
			"closeOnSelected": true,
			"timelistScroll": true,
			"calendarMouseScroll": false,
			"todayButton": true,
			"closeButton": true,
			"dateOnly": false,
			"timeOnly": false,
			"futureOnly": false,
			"minDate" : null,
			"maxDate" : null,
			"autodateOnStart": true,
			"minTime":"00:00",
			"maxTime":"23:59",
			"onShow": null,
			"onHide": null,
			"onSelect": null,
			"allowWdays": null,
			"amPmInTimeList": false,
			"externalLocale": null,
			// Amethyst content
			"invertedClass": "inverted",
			"invertedParents": true
			// end of Amethyst content
		};
	};

	/**
	 * Initialize dtpicker
	 */
	$.fn.dtpicker = function(config) {
		var date = new Date();
		var defaults = getDefaults();

		if(typeof config === "undefined" || config.closeButton !== true){
			defaults.closeButton = false;
		}

		defaults.inputObjectId = undefined;
		var options = $.extend(defaults, config);

		return this.each(function(i) {
			init($(this), options);
		});
	};

	/**
	 * Initialize dtpicker, append to Text input field
	 * */
	$.fn.appendDtpicker = function(config) {
		var date = new Date();
		var defaults = getDefaults();

		if(typeof config !== "undefined" && config.inline === true && config.closeButton !== true){
			defaults.closeButton = false;
		}

		defaults.inline = false;
		var options = $.extend(defaults, config);

		if (options.externalLocale != null) {
			lang = $.extend(lang, options.externalLocale);
		}

		return this.each(function(i) {
			/* Checking exist a picker */
			var input = this;
			if(0 < $(PickerObjects[$(input).data('pickerId')]).length) {
				return;
			}

			/* Add input-field with inputsObjects array */
			var inputObjectId = InputObjects.length;
			InputObjects.push(input);

			options.inputObjectId = inputObjectId;

			/* Current date */
			var date, strDate, strTime;
			if($(input).val() != null && $(input).val() !== ""){
				options.current = $(input).val();
			}

			/* Make parent-div for picker */
			var $d = $('<div>');
			if(options.inline){ // Inline mode
				$d.insertAfter(input);
			} else { // Float mode
				$d.css("position","absolute");
				$('body').append($d);
			}

			/* Initialize picker */

			var pickerId = PickerObjects.length;

			var $picker_parent = $($d).dtpicker(options); // call dtpicker() method

			var $picker = $picker_parent.children('.datepicker');

			/* Link input-field with picker*/
			$(input).data('pickerId', pickerId);

			/* Set event handler to input-field */

			$(input).keyup(function() {
				var $input = $(this);
				var $picker = $(PickerObjects[$input.data('pickerId')]);
				if ($input.val() != null && (
					$input.data('beforeVal') == null ||
					( $input.data('beforeVal') != null && $input.data('beforeVal') != $input.val())	)
				) { /* beforeValue == null || beforeValue != nowValue  */
					var format = getDateFormat($picker.data('dateFormat'), $picker.data('locale'), $picker.data('dateOnly'), $picker.data('timeOnly'));
					var date = parseDate($input.val(), format);
					//console.log("dtpicker - inputKeyup - format: " + format + ", date: " + $input.val() + " -> " + date);
					if (date) {
						draw_date($picker, {
							"isAnim":true,
							"isOutputToInputObject":false
						}, date);
					}
				}
				$input.data('beforeVal', $input.val());
			});

			$(input).change(function(){
				$(this).trigger('keyup');
			});

			var handler = new PickerHandler($picker, $(input));

			if(options.inline === true){
				/* inline mode */
				$picker.data('isInline',true);
			} else {
				/* float mode */
				$picker.data('isInline',false);
				$picker_parent.css({
					"zIndex": 100
				});
				$picker.css("width","auto");

				/* Hide this picker */
				$picker.hide();

				/* Set onClick event handler for input-field */
				$(input).on('click, focus',function(ev){
					ev.stopPropagation();
					var $input = $(this);
					var $picker = $(PickerObjects[$input.data('pickerId')]);

					// Generate the handler of a picker
					var handler = new PickerHandler($picker, $input);
					// Get the display state of a picker
					var is_showed = handler.isShow();
					if (!is_showed) {
						// Show a picker
						handler.show();
						// Call a event-hanlder
						var func = $picker.data('onShow');
						if (func != null) {
							func(handler);
						}
					}
				});

				// Set an event handler for resizing of a window
				(function(handler){
					$(window).resize(function(){
						handler._relocate();
					});
					$(window).scroll(function(){
						handler._relocate();
					});
				})(handler);
			}

			// Set an event handler for removing of an input-field
			$(input).bind('destroyed', function() {
				var $input = $(this);
				var $picker = $(PickerObjects[$input.data('pickerId')]);
				// Generate the handler of a picker
				var handler = new PickerHandler($picker, $input);
				// Destroy a picker
				handler.destroy();
			});

			// Call a event-handler
			var func = $picker.data('onInit');
			if (func != null) {
				console.log("dtpicker- Call the onInit handler");
				func(handler);
			}
		});
	};

	/**
	 * Handle a appended dtpicker
	 * */
	var methods = {
		show : function( ) {
			var $input = $(this);
			var $picker = $(PickerObjects[$input.data('pickerId')]);
			if ($picker != null) {
				var handler = new PickerHandler($picker, $input);
				// Show a picker
				handler.show();
			}
		},
		hide : function( ) {
			var $input = $(this);
			var $picker = $(PickerObjects[$input.data('pickerId')]);
			if ($picker != null) {
				var handler = new PickerHandler($picker, $input);
				// Hide a picker
				handler.hide();
			}
		},
		setDate : function( date ) {
			var $input = $(this);
			var $picker = $(PickerObjects[$input.data('pickerId')]);
			if ($picker != null) {
				var handler = new PickerHandler($picker, $input);
				// Set a date
				handler.setDate(date);
			}
		},
		setMinDate : function( date ) {
			var $input = $(this);
			var $picker = $(PickerObjects[$input.data('pickerId')]);
			if ($picker != null) {
				var handler = new PickerHandler($picker, $input);
				// Set a min date
				handler.setMinDate(date);
			}
		},
		setMaxDate : function( date ) {
			var $input = $(this);
			var $picker = $(PickerObjects[$input.data('pickerId')]);
			if ($picker != null) {
				var handler = new PickerHandler($picker, $input);
				// Set a max date
				handler.setMaxDate(date);
			}
		},
		getDate : function( ) {
			var $input = $(this);
			var $picker = $(PickerObjects[$input.data('pickerId')]);
			if ($picker != null) {
				var handler = new PickerHandler($picker, $input);
				// Get a date
				return handler.getDate();
			}
		},
		destroy : function( ) {
			var $input = $(this);
			var $picker = $(PickerObjects[$input.data('pickerId')]);
			if ($picker != null) {
				var handler = new PickerHandler($picker, $input);
				// Destroy a picker
				handler.destroy();
			}
		}
	};

	$.fn.handleDtpicker = function( method ) {
		if ( methods[method] ) {
			return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
		} else if ( typeof method === 'object' || ! method ) {
			return methods.init.apply( this, arguments );
		} else {
			$.error( 'Method ' +  method + ' does not exist on jQuery.handleDtpicker' );
		}
	};

	if (!window.console) { // Not available a console on this environment.
		window.console = {};
		window.console.log = function(){};
	}

	/* Define a special event for catch when destroy of an input-field. */
	$.event.special.destroyed = {
		remove: function(o) {
			if (o.handler) {
				o.handler.apply(this, arguments);
			}
		}
	};

	/* Set event handler to Body element, for hide a floated-picker */
	$(function() {
		$('body').click(function() {
			for (var i=0;i<PickerObjects.length;i++) {
				var $picker = $(PickerObjects[i]);
				if ($picker.data('inputObjectId') != null && !$picker.data('isInline') && $picker.css('display') != 'none') {
					/* if append input-field && float picker */

					// Check overlapping of cursor and picker
					if ($picker.is(':hover')) continue;

					// Check overlapping of cursor and input-field
					var $input = $(InputObjects[$picker.data('inputObjectId')]);
					if ($input.is(':focus')) continue;

					// Hide a picker
					var handler = new PickerHandler($picker, $input);
					handler.hide();

					// Call a event-hanlder
					var func = $picker.data('onHide');
					if (func != null) {
						console.log('dtpicker- Call the onHide handler');
						func(handler);
					}
				}
			}
		});
	});

})(jQuery);
// require "shards/fittext/_fittext.js"

// Offcanvas menu (pick one)
// require "shards/navigation_offcanvas_top/_navigation_offcanvas_top.js"
// require "shards/navigation_offcanvas_slideover/_navigation_offcanvas_slideover.js"
// require "shards/navigation_offcanvas_slide/_navigation_offcanvas_slide.js"


(function($, undefined){

	// Local variables
	var resizeTimer;
	var $window = $(window);
	var $document = $(document);

	// Project scripts

	$document.on('click', '.star-holder A', function(event) {
		var $this = $(this);
		$this.tooltip('hide');
		var $holder = $this.closest('.star-holder');

		if ($this.hasClass('star-empty')) {
			// Check
			$holder.addClass('star-checked');
			//$holder.find('.star-full').tooltip('show');
		} else {
			// Uncheck
			$holder.removeClass('star-checked');
			//$holder.find('.star-empty').tooltip('show');
		}
		event.preventDefault();
	});

	$('[data-toggle="tooltip"]').tooltip({
		container: 'body'
	});

	$('#register-modal-input-bd').appendDtpicker({
		"dateOnly": true
	});

	// Swiper
	var mySwiper = new Swiper ('.swiper-container', {
		// Optional parameters
		slidesPerView: 1,
		speed: 470,
		autoplay: 4000,
		//freeMode: true,
		loop: true,
		keyboardControl: true,
		mousewheelControl: false,

		// Enable lazy loading
		preloadImages: false,
		lazyLoading: true,
		lazyLoadingInPrevNext: true,

		// If we need pagination
		pagination: '.swiper-pagination',
		paginationClickable: true,

		// Navigation arrows
		nextButton: '.swiper-button-next',
		prevButton: '.swiper-button-prev',
	});

	// ------------------------------
	// Resize & orientation change functions with 100ms timer

	function resizeElements() {
		// Some recalculations on resize

		// ...
	}
	$window.on('resize', function() {
		clearTimeout(resizeTimer);
		resizeTimer = setTimeout(resizeElements, 100);
	});
	// Bind orientation change
	$window.on('orientationchange', function() {
		resizeElements();
	});
	// Fire once at startup
	resizeElements();

})(jQuery);